# 3. 상속

- **상속(`extends`)**
  ```
  // Child 클래스가 Parent 클래스로부터 상속받는다
  public class Child extends Parent { 
    ...
  }
  ```
  - 자식 클래스는 부모 클래스의 멤버변수/메서드를 모두 상속받아 사용 가능
  - 또한, 자식은 부모로부터 물려받은 것 외에 자신이 독립적으로 멤버변수/메서드를 선언하여 독자적으로 사용 가능  
    단, 이때 부모 클래스의 private 멤버변수에 접근하려면 반드시 부모로부터 상속받은 메서드를 통해서만 가능  
    (자식만 가지고 있는 메서드로는 부모의 private에 접근 불가하고 오직 public이나 protected에만 접근 가능)
  - 역으로 부모가 자식의 멤버변수/메서드에 접근하는 것은 불가능
  

- **개체 생성 순서**
  1) 메모리에 개체 생성
  2) 부모 초기화
  3) 자식 초기화

  
- **`super` 키워드**
  만약 부모 클래스가 있고, 그 부모 클래스에 매개변수를 받는 생성자가 있다면,  
  반드시 자식 클래스 생성자 가장 첫번째 줄에 부모 생성자를 호출해주는 코드   
  => super(매개변수 목록) 가 존재해야 하며,  
  만약 반대 순서로 부모보다 자식 멤버변수 먼저 초기화 하면 컴파일 에러가 뜸.  
  (하지만 부모 클래스에 매개변수를 받는 생성자가 없다면 자식 클래스 생성자에 부모 생성자를 호출해주는 코드가 없어도  
  어차피 컴파일러가 알아서 부모 클래스의 디폴트 생성자를 호출해주기 때문에 상관없음)  

  ```
  public class Parent {
      public Parent(String str) {
          ...
      }
      ...
  }

  public class Child extends Parent {
      private String childStr;
      public Child(String str) {
          super(str); // super 키워드를 통해 부모의 매개변수를 받는 생성자부터 초기화시켜줌
          // 이후 자식의 멤버변수 초기화(만약 이 코드와 바로 위에 부모 생성자 초기화 코드의 순서가 바뀌면 컴파일 오류)
          childStr = "Child"; 
      }
      ...
  }
  ```
  
  - `super` 키워드 : 현 개체의 부모 부분을 가리키며, 다음과 같이 사용 가능
    - `super(매개변수 목록)` : 부모 클래스의 생성자 호출
    - `super.부모의멤버변수` / super.부모의메서드 : 부모 클래스의 멤버 변수/메서드를 호출

  - 부모로부터 물려받은 private 멤버 변수를 어느 특정 자식 클래스만 바꿀 수 있게끔 하고싶다면  
  부모클래스에서 해당 멤버변수 접근제어자를 protected로 지정하고,  
  그 특정 자식 클래스에 아래처럼 set 메서드를 추가하면 됨  
  ```
  private setVal(String inheritedVal) {
    // 여기서 super대신 this 사용 가능. 단, 부모의 멤버라는걸 명백히 구분해주기 위해 가급적이면 super 키워드 사용 권장
    super.inheritedVal = inheritedVal; 
  }
  ```
    
  
- **부모형 변수와 자식형 변수 대입과 형변환(캐스팅)**  
  `public class Person {}`  
  `public class Student extends Person {}`  
  `public class Teacher extends Person {}`  

  1) 부모 <- 자식 대입 가능(이때, 부모 <- 자식 대입에는 컴파일러가 암묵적으로 형변환(캐스팅)을 해줌)  
     즉, `Person person = new Student(); // 가능`

  2) 하지만 반대는 불가능  
     `Student student = new Person(); // 컴파일 오류`

  3) 단, 아래처럼 명시적으로 형변환을 해주면 가능  
      ```
      Person person = new Person();  
      Student student = (Student)person; // 형변환을 해주면 가능  
      ```
  4) 하지만 같은 부모를 공유하더라도 서로 상속 관계가 아닌 클래스끼리는 형변환을 해도 대입 불가능  
     ```
     Teacher teacher = new Teacher();
     Student student = (Student)teacher; // 컴파일 오류
     ```
  
- `instanceof` 연산자 : 만약 해당 클래스와 같은 상속 라인 위에 있을 경우 모두 같은 계열의 클래스로 인식
  ``` 
  public class Person {}
  
  public class Teacher extends Person {}
  
  public class PartTimeTeacher extends Teacher {

    public static boolean checkInstanceOf(PartTimeTeacher partTimeTeacher ) {
        boolean ret = false;
        if (partTimeTeacher instanceof Teacher) { // True
            ret = true;
        }
        if ((partTimeTeacher instanceof Person) { // True
            ret = true;
        }
        return ret;
    }
  }
  ```

- **클래스 형변환 시 주의점**
  ``` 
  public class Person {}
  public class Teacher extends Person {}
  public class Student extends Person {
  ...
      public static Student convertToPerson(Person person) {
          Student student = (Student)person;
          return student;
      }
  }
  ```
  Student클래스의 convertToPerson 메서드에서 파라미터로 들어오는 person 객체가  
  진짜 순수 Person 클래스의 객체인지, 아니면 Teacher가 명시적 형변환을 통해 Person 타입이 된 객체인지 알 수가 없으며,  
  따라서 convertToPerson 메서드 내의 Student 객체에 Person 객체를 형변환하여 대입할 때 문제가 발생할 수 있음.  
  (이렇게 클래스 형변환이 적용될 때마다 예외처리를 하는 것은 비효율적)  
  => 결국 부모형 변수에 저장된 객체가 실제적으로는 어떤 자식형인지 알 방법이 필요.  
  => instanceof 연산자 혹은 getClass()로 해결 가능  
  ``` 
  // instanceof 연산자를 활용
  public static Student convertToPerson(Person person) {
      Student student = null;
      if (person instanceof Student) { // person 객체가 순수 Student 클래스 타입일 경우에만 형변환하여 자식 클래스 변수에 대입해줌
          student = (Student)person;
      }
      return student;
  }
  
  // 모든 클래스의 최상위 부모인 Object 클래스의 메서드 getClass()를 활용
  public static Student convertToPerson(Person person) {
      Student student = null;
      if (person.getClass() == student.getClass()) { // person 객체가 순수 Student 클래스 타입일 경우에만 형변환하여 자식 클래스 변수에 대입해줌
          student = (Student)person;
      }
      return student;
  }
  ```

- ※ **Base Entity Class** : 실무에서 사용하는 모든 공통적인 속성(멤버변수, 메서드)를 묶어서 활용해 코드중복을 최소화 하기 위한 기본 클래스  
=> 게임에서는 GameObject 클래스
  

- **다중 상속**  
  - 다중 상속이 발생하는 이유 : 하나의 클래스가 서로 다른 양상의 특징들을 상속받으려고 함.  
    ex) 디지털 손목시계의 경우 '디지털'과 '손목에 건다'라는 서로 다른 양상의 특징들을 상속받으려고 하기 때문에 다중 상속 발생.
  - 다중상속의 문제점 : 가장 최하위 클래스는 최상위 클래스를 의도치않게 여러번 상속할 수 있어서 관리하는데에 오히려 더 복잡해질 수 있음.
  - JAVA에서는 다중상속을 지원하지 않음(C++에서는 지원함)
  - 다중 상속을 해결하는 방법
    1) 추상화
    2) 인터페이스  
    => 추상화 vs 인터페이스 
  

- **상속 vs 컴포지션** : 클래스를 상속 관계로 구성할건지, 아니면 컴포지션 관계로 구성할건지 결정하는 것은 OOP에서 중요한 이슈
  - is-a(상속) 관계
    - PartTimeTeacher extends Teacher / Teacher extends Person / Person
    - 즉, 수학의 부분집합처럼 PartTimeTeacher는 곧 Teacher고, Teacher는 곧 Person이다.(역은 성립 불가)
  - has-a(컴포지션) 관계
    - WaterSpray = SprayHead + WaterBottle
    - 즉, 포함관계로 WaterSpray에는 SprayHead와 WaterBottle이 포함
  

- **상속 vs 컴포지션 선택 조건(둘다 재사용성을 위해 사용)**
  1. 메모리 및 성능이 중요한 경우 :  
  상속의 경우 개체 생성시 메모리가 하나의 블록 단위 / 컴포지션의 경우 부품 개체 수만큼의 메모리 블록을 가짐.  
  -> new 키워드 하나당 메모리 블록 하나에 대응  
  한편, 메인메모리에서 CPU의 캐시메모리로 데이터를 가져올 때 상속 모델로 만든 개체의 경우 메모리 블록이 하나이기 때문에  
  데이터가 한 번에 캐시 메모리로 들어갈 확률이 높음(성능 향상).  
  반면, 컴포지션 모델로 만든 개체의 경우 관련된 메모리 블록이 여러개이기 때문에 개체 내 부품 수 만큼 캐시 메모리로 로딩될 가능성이 높음.  
  또한, 상속은 메모리 할당과 해제가 딱 한번씩만 이루어지는 반면에 컴포지션은 한번 + 부품 수만큼씩 메모리 할당/해제가 이루어짐.  
  2. 다형성이 중요한 경우 :  
  -> ex) 여러 종류의 자식 개체들을 공통 부모형의 List에 담고 for문을 돌려 다형적인 작업을 할 경우
  3. 상속은 부모가 가진 부분을 재사용 vs 컴포지션은 각 개체의 필요한 부분을 부품처럼 활용.  
     (깊은 상속보다는 컴포지션이 나을 수 있음)
  4. 상속vs컴포지션이 헷갈리는 경우에는 해당 케이스가 여러 부품을 가지고 있는 특징이 강한지(컴포지션), 아니면 어느 특정 종류 중 하나인 케이스인지(상속) 구분하여 사용.
  

- **엔티티 컴포넌트 시스템** : 다양한 특성들을 부품(Component)들로 만들고, 그것을 가지고 조립해서 하나의 Object로 만들어 사용하는 방식.  
  => 깊은 상속에 대해 클래스들간의 상속 관계가 자주 바뀔 때 발생하는 문제 해결 가능
  ``` 
  class Object {
    ArrayList<Component> List; // Object 클래스는 여러 컴포넌트들로 구성됨
  }
  
  class Component {
  }
  
  // 컴포넌트는 다음의 여러가지 특징을 가질 수 있음
  class ControllableComponent extends Component {
  }
  
  class EntityComponent extends Component {
  }
  
  class PhysicsComponent extends Component {
  }
  ```

- ※ 클래스를 재사용하면 좋은 점
  1. 테스트에 걸리는 시간 절약 가능
     - 하지만 이미 어느정도 테스트까지 끝낸 클래스라도 예전에 발견하지 못한 추가적인 버그 나올 수 있고,
       해당 클래스를 가져다 쓰면서 예상치 못한 버그 또한 발생할 수 있으므로 그에 대한 테스트도 필요.
  2. 관리 비용 절약 가능
     - 코드 중복이 없음 