# static, 싱글턴, 내포클래스

- **정적(static) 멤버 함수** : 이 멤버 함수의 소유주는 개체가 아니라 클래스
  ```
  // Math라는 클래스의 public 메서드 abs
  public static int abs(int n) {
      return n < 0 ? -n : n;
  }  
  ...
  public static void main(String[] args) {
      int absValue = Math.abs(-2); // Math 클래스의 정적 멤버 함수 abs 호출
  } 
  ```
  이렇게 정적 멤버 함수를 호출할 때에는 개체로부터가 아니라 <클래스명>.<메서드명>() 이렇게  
  직접 클래스를 통해서 호출하고, new키워드를 통해 Math 개체를 생성하지 않아도 됨.  
  즉, 위 Math처럼 정적(static) 클래스의 경우에는 new를 통해 개체를 생성하는 것이 오히려 메모리 낭비일 수 있기 때문에  
  생성자를 private로 선언해서 개체 생성을 막아주는 것이 좋음.  

  
- **정적(static) 메서드 주의사항** :   
  static 메서드는 클래스 소속이기에 static 멤버 함수/변수만 사용 가능하며,  
  개체에 속한 멤버(함수/변수)에는 접근할 수 없음.  
  (왜냐하면 어느 특정 개체의 것에 접근해야 하는지 알 수가 없기때문에)  
  단, 개체의 멤버(함수/변수)에서는 static 함수/변수 접근 가능.
  - 비정적 -> 정적 접근 가능
  - 정적 -> 비정적 접근 불가

  
- **정적(static) 멤버 변수** : 정적 멤버 함수처럼 이 멤버 변수의 소유주는 개체가 아니라 클래스  
  ```
  // Human 클래스의 개체가 총 몇개 생성됐는지 확인하려면 다음처럼 Human 클래스의 정적 멤버 변수를 활용 가능
  public class Human {
    private static int humanCnt; // 생성된 Human 클래스 개체 수

    public Human() {  // 생성자를 호출할 때마다 정적 멤버 변수 humanCnt값을 증가시켜줌
        this.humanCnt++;
    }
  }  
  ```

- **static의 생명주기** : C/C++의 전역 함수/변수처럼 프로그램 시작할때부터 끝날때까지  

  
- **static 사용시 유의점** : static은 접근제어자 사용이 가능하고, 이름 충돌 가능성이 적다는 점에서 전역 변수보다 관리가 편하지만,  
  해당 멤버 변수/함수를 클래스의 소유로 해야하는지, 아니면 개체의 소유로 해야하는지 명확히 구분하여 static 올바르게 사용 필요. 


- **싱글턴 패턴** : 어떤 클래스에서 만들 수 있는 인스턴스 수를 하나로 제한하는 방식으로, static의 방식을 개체지향적으로 풀어냄
  - 프로그램 실행중에 최대 하나만 있어야 함
  - 이 개체에 전역적으로 접근이 가능해야 함 

  ```
  public class Singleton {
      private static Singleton instance; // 자기 자신 type의 instance를 갖는 자체형 클래스 
    
      private Singleton() { // 생성자는 private
      }
  
      /* 클래스 소유의 정적(static) 메서드 */
      // 외부에서는 static 메서드(ex. getInstance())를 통해서만 개체를 얻어올 수 있음
      public static Singleton getInstance() {
          if (instance == null) {
              // 아직 개체가 생성되지 않았을 경우엔 클래스 내부에서 생성자로 개체 생성 후 static 변수에 저장 후 개체 반환. 
              instance = new Singleton();
          }
           
          // 만약 이미 개체가 있는 경우엔 이미 static 변수에 저장되어 있는 개체를 반환  
          return instance;
      }
  } 
  ```

**※ 디자인 패턴** : 문제 해결 가이드를 정리해놓은 것으로, 잘 모르고 쓰면 프로그램 코드가 이상해질 수도 있음.  
-> 주어진 디자인 패턴에 반드시 종속될 필요는 없으며, 얼마든지 변형하여 사용 가능.(즉, 반드시 올바른 디자인 패턴이란 없음)  
-> 디자인 패턴 자체에 집중하기 보다는 내 짠 코드를 사용하는 다른 사람(혹은 미래의 나)이 실수할 가능성을 가급적이면 줄이는 것에 집중하기  

- 싱글턴 패턴을 사용하는 올바른 예 : 설정(Configuration) 정보 클래스  
-> 프로그램에 전체에 대한 설정 정보는 하나만 존재하는 것이 바람직하기 때문
  

- **싱글턴 패턴 vs static**  (static으로는 못하는 일)
  1. 다형성 사용 불가
  2. 시그니처를 그대로 둔 채 멀티턴 패턴(최대 생성가능한 개체 갯수가 정해진 패턴)으로 전환 불가
  3. 개체의 생성 시점을 제어할 수 없음(JAVA의 static은 프로그램이 처음 시작되는 시점에 초기화됨)


- **내포 클래스(Nested Class)**
  - 내포클래스의 용도 : 서로 연관된 클래스들을 클래스 속에 넣어 긴밀하게 그룹지어 관리 가능  
  - 내포클래스는 바깥 클래스의 private 멤버에 접근 가능(하지만 그 반대는 불가능 -> 변수들이 선언된 블록 범위{} 개념으로 이해하면 쉬움)  
    => 덕분에 패키지 접근제어자보다 강한 캡슐화가 가능

  - 정적 내포 클래스(C#, C++, Java에서 지원)
  - 비정적 내포 클래스(Java만 지원)  
    => 이 둘의 차이는 정적 내포 클래스는 외부 클래스의 레퍼런스를 프로그래머가 직접 생성자를 통해 지정해줘야 되지만,  
    비정적 내포 클래스는 자바에서 자동으로 외부 클래스와 연결해줌  
    사실, C#이나 C++에서는 내포클래스가 기본적으로 정적 내포클래스이기 때문에 앞에 따로 static을 붙이지 않지만, Java에서는 이를 구분하기 위해  
    정적 멤버 변수/메서드에서의 모든 개체가 공유한다는 static의 의미와는 상관 없는 static 키워드를 붙였다는 점에서 혼란의 여지는 있음.  