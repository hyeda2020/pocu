# 개체 : 상태 + 동작 = (데이터 + 메서드)


# 자바에서의 객체는 C++에서의 레퍼런스다!(C언어에서의 포인터)


# 객체는 포인터, 즉 참조형이기 때문에 메서드 안에서 객체의 멤버변수 값을 바꾸면 메서드 밖의 원본에도 영향을 미친다 


# 객체는 포인터이며, 모두 동적으로 할당(new 키워드)되기 때문에 힙 메모리에 저장된다.
단, 일반 자료형(int, float, double) 변수는 스택 메모리에 저장된다.


# 다형성 : 하나의 기능에 대해 서로 다르게 동작하는 것
  추상화 : 구체적인 내용이 아닌, 일반화된 내용에 집중하는 것

가령, 택배를 시킬 때, 택배 배달은 오토바이를 통해서, 트럭을 통해서, 혹은 드론을 통해서 진행이 될 수 있음.
즉, 같은 택배 배달이라도 서로 다른 방식으로 진행이 될 수 있음 -> 다형성

하지만, 소비자 입장에서는 택배 배달이 구체적으로 어떤 방식으로 진행되는지 굳이 신경쓸 필요가 없으며,
오직 '택배 배달을 하면 물건이 내 집에 온다' 라는 택배 배달의 보다 일반화된 속성에 집중하면 됨 -> 추상화

결국, 추상화와 다형성은 곧 '역할과 구현의 분리'와 밀접하게 연결

=> 자바에서는 이를 추상 클래스와 인터페이스를 통해 활용


# OOP 4개 특성 : 캡슐화, 상속, 다형성, 추상화


# 객체 생성시 따로 지정하지 않아도 멤버변수는 자동으로 int형은 0, float는 0.0, 그 외 참조형은 null로 초기화가 된다.


# 생성자 : 개체가 생성과 동시에 올바른 상태임을 보장해주는 일종의 함수
즉, 콜라를 샀는데 캔 내부에 내용물이 비어있을 가능성이 없다는 것을 보장해줌.

=> 개체의 멤버변수를 초기화하는 코드의 중복을 막아주고, 덕분에 멤버변수가 추가/제외되어도 개체를 초기화하는 데에 있어서 프로그래머의 실수를 줄여줌



# 매개변수가 있는 생성자가 정의되면, 
매개변수가 없는 생성자도 추가로 정의해주지 않으면 
컴파일러가 자동으로 제공해주던 매개변수가 없는 생성자는 사용 불가

즉, 
public class Human {
    ...
    public Human(int a) // 매개변수가 있는 생성자만 존재
    {
        ...
    }
    ....
}

...
public static void main(String[] args) {
     Human h = new Human();  // 컴파일 오류
...
}



# this() : 같은 클래스의 다른 생성자를 코드 중복 없이 편하게 호출
public class Human {
    String name;
    int age;
    int a;

    public Human(String name, int age) {
        // 코드 중복 발생
        this.name = name;
        this.age = age;
    }

    public Human(String name, int age) {
        // this() 키워드를 통해 같은 클래스의 다른 생성자를 코드 중복 없이 편하게 호출
        this(name, age); // 생성자 코드의 가장 위에 있어야 함
        //this.age = 0;
    }
    
}



# 클래스/개체는 자신의 상태를 사람이 아닌, 클래스/개체 스스로가 책임지도록 만들어야 함!
=> 즉, 개체 외부에서 개체의 상태에 직접 접근하는 것을 막아야 함(개체의 상태는 오로지 개체 자신만 바꿀 수 있어야 함)
=> 접근 제어자(Getter, Setter) 사용


# 일반적으로 클래스 선언에 대한 접근제어자는 public, 혹은 접근제어자 생략만 가능하지만,
클래스 안에 정의된 또 다른 클래스, 즉 내포클래스의 경우에는 private, protected도 사용 가능


# 메서드는 보통 public을 하지만, 
멤버 변수는 private로 하고 메서드를 통해서만 접근 가능하게끔 => 캡슐화, 데이터 추상화
단, 메서드를 private로 선언하는 경우에는 주로 코드 중복을 피할 목적으로 해당 메서드를 클래스 내부에서만 사용하기 위함 

# 이때, 내부란 개체의 내부가 아니라 클래스의 내부를 의미
즉, 같은 클래스라면 서로 다른 개체는 서로의 내부에 접근 가능!

# 좋은 프로그래밍 습관 : 중복 코드를 최소화하자!

# 직접 멤버변수에 접근하지 않고 getter/setter 메서드를 사용할 때의 장점 : 
- getter/setter내에 Validation Check 등의 추가적인 로직 포함 가능
- 상속을 통한 다형성 구현 가능

# getter는 자유롭게 추가하되, 레퍼런스 타입(주로 클래스)인 경우에는 getter로 리턴되고 나서 외부에서 값을 수정할 경우,
내부에도 영향을 미치기 때문에 이런 경우에는 조심하기

# setter는 무조건 넣지 말고, 변경되면 안되는 멤버변수일 경우에는 setter는 추가하지 않기
-> 이런 경우에는 필요할 때 만들어 사용하자!


# 캡슐화 : 
- 개체의 데이터(멤버 변수)와 동작(메서드)를 하나로 묶음
- 내부의 데이터를 외부로부터 보호(마치 사용자가 함수 속이 어떻게 구현되어있는지 알 필요가 없는 것처럼 외부에서 클래스 내부를 알 필요가 없다)

# 추상화 : 구체적인 내부(private 멤버 변수)에 직접 접근하지 않음


# 함수는 가급적이면 여러 동작을 하기 보다는 명백한 하나의 동작을 하는게 좋다


# 한번에 모든 것을 다 완벽하게 담으려고 하지 말고, 그때그때 필요할 때마다 코드를 추가하는 것이 좋다
- 기존 소스에 수정사항이 생겼을 경우 사용하지도 않은 수많은 변수, 메서드들임에도 소스 수정에 따라 영향도가 발생하지 않는지 일일이 확인해야 될 수도 있음
=> 즉, 많은 내용으로 시작했다가 변경사항이 생겨서 나중에 한꺼번에 뒤엎기 보다는, 단순하게 시작해서 점점 살을 붙여가는게 좋다



# 유연성이 높다(=코드 재사용성이 높다)고 해서 무조건 좋은 것은 아니다!
- 유연성을 높이려면 클래스를 잘게 쪼개는 과정이 필요한데, 이로 인해 오히려 복잡성이 크게 증가할 수 있음!
=> 이로 인해 결국 성능 저하 및 가독성이 떨어질 수 있음
=> 즉, 정말 자주 사용하는 것에 대해서만 유연성을 높이자!



# 결국 중요한건 기본기!
1. 우선 기본기부터 확실히 잡기
- 읽기 명확한 코드 만들기
- 실수를 저지르기 어려운 코드 만들기
- 문제를 해결하는 코드 만들기
- 문제가 생기면 디버깅하기


2. 그렇게 기본기를 바탕으로 문제를 해결한 이후 필요하면 그때 가서 유연성을 높이기!
(유연성이 필요 없다면 굳이 하지 않는게 좋음)


# 함수가 특정 작업을 수행하고, 그 작업과 관련 없는 값을 리턴하는 것은 직관적이지 않고 명백하지 않지만
함수에서 특정 작업을 수행하고, 그 결과의 성공 여부를 boolean 타입으로 반환(성공하면 true, 실패하면 false) 하는 정도는 
성공여부를 확인할 필요가 있는 경우에 대해선 나름 합리적 


# 특정 함수가 Null을 리턴할 수 있으면 함수명에 OrNull을 붙이기
# 특정 변수가 Null값일 수 있으면 변수명에 OrNull을 붙이기


# 정적(static) 멤버 함수 : 이 멤버 함수의 소유주는 개체가 아니라 클래스
// Math라는 클래스의 public 메서드 abs
public static int abs(int n) {
    return n < 0 ? -n : n;
}

int absValue = Math.abs(-2); // Math 클래스의 정적 멤버 함수 abs 호출
=> 이렇게 정적 멤버 함수를 호출할 때에는 개체로부터가 아니라 <클래스명>.<메서드명>() 이렇게
클래스를 통해서 호출하고, new키워드를 통해 Math 개체를 생성하지 않아도 됨.

즉, 위 Math처럼 정적(static) 클래스의 경우에는 new를 통해 개체를 생성하는 것이 오히려 메모리 낭비일 수 있기 때문에
생성자를 private로 선언해서 개체 생성을 막아주는 것이 좋음


# 정적(static) 멤버 변수 : 정적 멤버 함수처럼 이 멤버 변수의 소유주는 개체가 아니라 클래스
=> 가령, Human 클래스의 개체가 총 몇개 생성됐는지 확인하려면 다음처럼 Human 클래스의 정적 멤버 변수를 활용 가능
public class Human {
    private static int humanCnt; // 생성된 Human 클래스 개체 수

    public Human() {  // 생성자를 호출할 때마다 정적 멤버 변수 humanCnt값을 증가시켜줌
        this.humanCnt++;
    }
}


# static 메서드에서는 static 멤버 함수/변수만 사용 가능!
즉, 클래스에 속한 메서드는 개체에 속한 멤버(함수/변수)에는 접근할 수 없음!!
왜냐하면 어느 특정 개체의 것에 접근해야 하는지 알 수가 없기때문에!!
단, 개체의 멤버(함수/변수)에서는 static 함수/변수 접근 가능!

비정적 -> 정적 접근 가능!
정적 -> 비정적 접근 불가!


# 해당 멤버 변수/함수를 클래스의 소유로 해야하는지, 아니면 개체의 소유로 해야하는지 명확히 구분하여 static 올바르게 사용!


# static의 생명주기는 C/C++의 전역 함수/변수처럼 프로그램 시작할때부터 끝날때까지
또한, static은 접근제어자 사용이 가능하고, 이름 충돌 가능성이 적다는 점에서 전역 변수보다 관리가 편함



# 디자인 패턴 : 문제 해결 가이드를 정리해놓은 것
- 단점 : 잘 모르고 쓰면 프로그램 코드가 이상해질 수도 있음


# 싱글턴 패턴 : 어떤 클래스에서 만들 수 있는 인스턴스 수를 하나로 제한하는 방식으로, static의 방식을 개체지향적으로 풀어냄
- 프로그램 실행중에 최대 하나만 있어야 함
- 이 개체에 전역적으로 접근이 가능해야 함

생성자는 private이고, 외부에서는 static 메서드(ex. getInstance())를 통해서만 개체를 얻어올 수 있음
이때, static 메서드에서는 아직 개체가 생성되지 않았을 경우엔 클래스 내부에서 생성자로 개체 생성 후 static 변수에 저장 후 개체 반환.
만약 이미 개체가 있는 경우엔 이미 static 변수에 저장되어 있는 개체를 반환

public class Singleton {
    private static Singleton instance; // 자기 자신 type의 instance를 갖는 자체형 클래스 
  
   private Singleton() {
   }

   /* 클래스 소유의 정적(static) 메서드 */
   public static Singleton getInstance() {
       if (instance == null) {
           instance = new Singleton();
       }

       return instance;
   }
}


# 싱글턴 패턴을 사용하는 올바른 예 : 설정(Configuration) 정보 클래스
-> 프로그램에 전체에 대한 설정 정보는 하나만 존재하는 것이 바람직하기 때문


# 싱글턴 패턴 vs static
- static으로는 못하는 일
 1. 다형성 사용 불가
 2. 시그니처를 그대로 둔 채 멀티턴 패턴(최대 생성가능한 개체 갯수가 정해진 패턴)으로 전환 불가 
 3. 개체의 생성 시점을 제어할 수 없음(JAVA의 static은 프로그램이 처음 시작되는 시점에 초기화됨)



# 주어진 디자인 패턴에 반드시 종속될 필요는 없으며, 얼마든지 변형하여 사용 가능.
(즉, 반드시 올바른 디자인 패턴이란 없다!) 

 
# 내 짠 코드를 사용하는 다른 사람(혹은 미래의 나)이 실수할 가능성을 가급적이면 줄이자! => 안전 수칙의 중요성!



# 좋은 프로그래머는 무의미한 주장에 신경쓰지 않고 단지 그 상황에 맞고 실수가 적은, 그리고 단순한 코드를 작성할 뿐



# 내포 클래스(Nested Class)
 - 내포클래스의 용도 : 서로 연관된 클래스들을 클래스 속에 넣어 긴밀하게 그룹지어 관리 가능
 - 내포클래스는 바깥 클래스의 private 멤버에 접근 가능(하지만 그 반대는 불가능 -> 변수들이 선언된 블록 범위{} 개념으로 이해하면 쉬움)
  => 덕분에 패키지 접근제어자보다 강한 캡슐화가 가능

 - 정적 내포 클래스(C#, C++, Java에서 지원)
 - 비정적 내포 클래스(Java만 지원)
  => 이 둘의 차이는 정적 내포 클래스는 외부 클래스의 레퍼런스를 프로그래머가 직접 생성자를 통해 지정해줘야 되지만,
       비정적 내포 클래스는 자바에서 자동으로 외부 클래스와 연결해줌
       사실, C#이나 C++에서는 내포클래스가 기본적으로 정적 내포클래스이기 때문에 앞에 따로 static을 붙이지 않지만, Java에서는 이를 구분하기 위해
       정적 멤버 변수/메서드에서의 모든 개체가 공유한다는 static의 의미와는 상관 없는 static 키워드를 붙였다는 점에서 혼란의 여지는 있음.


# 상속
public class Child extends Parent { // Child 클래스가 Parent 클래스로부터 상속받는다
...
}

- 자식 클래스는 부모 클래스의 멤버변수/메서드를 모두 상속받아 사용 가능
- 또한, 자식은 부모로부터 물려받은 것 외에 자신이 독립적으로 멤버변수/메서드를 선언하여 독자적으로 사용 가능
단, 이때 부모 클래스의 private 멤버변수에 접근하려면 반드시 부모로부터 상속받은 메서드를 통해서만 가능
(자식만 가지고 있는 메서드로는 부모의 private에 접근 불가하고 오직 public이나 protected에만 접근 가능)
- 역으로 부모가 자식의 멤버변수/메서드에 접근하는 것은 불가능


# 개체 생성 순서
1. 메모리에 개체 생성
2. 부모 초기화
3. 자식 초기화



# 만약 부모 클래스가 있고, 그 부모 클래스에 매개변수를 받는 생성자가 있다면, 
반드시 자식 클래스 생성자 가장 첫번째 줄에 부모 생성자를 호출해주는 코드 => super(매개변수 목록) 가 존재해야 하며 
만약 반대 순서로 부모보다 자식 멤버변수 먼저 초기화 하면 컴파일 에러가 뜸
(하지만 부모 클래스에 매개변수를 받는 생성자가 없다면 자식 클래스 생성자에 부모 생성자를 호출해주는 코드가 없어도 
어차피 컴파일러가 알아서 부모 클래스의 디폴트 생성자를 호출해주기 때문에 상관없음)

public class Parent {
    public Parent(String str) {
        ...
    }
    ...
}

public class Child extends Parent {
    private String childStr;
    public Child(String str) {
        super(str); // super 키워드를 통해 부모의 매개변수를 받는 생성자부터 초기화시켜줌
        childStr = "Child"; // 이후 자식의 멤버변수 초기화(만약 이 코드와 바로 위에 부모 생성자 초기화 코드의 순서가 바뀌면 컴파일 오류)
    }
    ...
}


# super 키워드 : 현 개체의 부모 부분을 가리키며, 다음과 같이 사용 가능
- super(매개변수 목록) : 부모 클래스의 생성자 호출 
- super.부모의멤버변수 / super.부모의메서드 : 부모 클래스의 멤버 변수/메서드를 호출




# 부모로부터 물려받은 private 멤버 변수를 어느 특정 자식 클래스만 바꿀 수 있게끔 하고싶다면 
부모클래스에서 해당 멤버변수 접근제어자를 protected로 지정하고, 
그 특정 자식 클래스에 아래처럼 set 메서드를 추가하면 됨
private setVal(String inheritedVal) {

    super.inheritedVal = inheritedVal; // 여기서 super대신 this 사용 가능. 단, 부모의 멤버라는걸 명백히 구분해주기 위해 가급적이면 super 키워드 사용 권장
}



# is-a(상속) 관계
- PartTimeTeacher extends Teacher / Teacher extends Person / Person
- 즉, 수학의 부분집합처럼 PartTimeTeacher는 곧 Teacher고, Teacher는 곧 Person이다.(역은 성립 불가)


# has-a(컴포지션) 관계
- WaterSpray = SprayHead + WaterBottle
- 즉, 포함관계로 WaterSpray에는 SprayHead와 WaterBottle이 포함


# 클래스를 상속 관계로 구성할건지, 아니면 컴포지션 관계로 구성할건지 결정하는 것은 OOP에서 중요한 이슈


# 부모형 변수와 자식형 변수 대입과 형변환(캐스팅)
public class Person {}
public class Student extends Person {}
public class Teacher extends Person {}

1) 부모 <- 자식 대입 가능(이때, 부모 <- 자식 대입에는 컴파일러가 암묵적으로 형변환(캐스팅)을 해줌)
즉, Person person = new Student(); // 가능

2) 하지만 반대는 불가능
Student student = new Person(); // 컴파일 오류

3) 단, 아래처럼 명시적으로 형변환을 해주면 가능
Person person = new Person();
Student student = (Student)person; // 형변환을 해주면 가능

4) 하지만 같은 부모를 공유하더라도 서로 상속 관계가 아닌 클래스끼리는 형변환을 해도 대입 불가능
Teacher teacher = new Teacher();
Student student = (Student)teacher; // 컴파일 오류



# 상속

public class Person {}
public class Teacher extends Person {}
public class Student extends Person {
    ... 
    public static Student convertToPerson(Person person) {
        Student student = (Student)person;
        return student;
    }
}

=> Student클래스의 convertToPerson 메서드에서 파라미터로 들어오는 person 객체가
진짜 순수 Person 클래스의 객체인지, 아니면 Teacher가 명시적 형변환을 통해 Person 타입이 된 객체인지 알 수가 없으며
따라서 convertToPerson 메서드 내의 Student 객체에 Person 객체를 형변환하여 대입할 때 문제가 발생할 수 있음
(이렇게 클래스 형변환이 적용될 때마다 예외처리를 하는 것은 비효율적)
=> 결국 부모형 변수에 저장된 객체가 실제적으로는 어떤 자식형인지 알 방법이 필요
=> instanceof 연산자 혹은 getClass()로 해결 가능!!

// instanceof 연산자를 활용
public static Student convertToPerson(Person person) {
    Student student = null;
    if (person instanceof Student) { // person 객체가 순수 Student 클래스 타입일 경우에만 형변환하여 자식 클래스 변수에 대입해줌
        student = (Student)person;
    }
    return student;
}

// 모든 클래스의 최상위 부모인 Object 클래스의 메서드 getClass()를 활용
public static Student convertToPerson(Person person) {
    Student student = null;
    if (person.getClass() == student.getClass()) { // person 객체가 순수 Student 클래스 타입일 경우에만 형변환하여 자식 클래스 변수에 대입해줌
        student = (Student)person;
    }
    return student;
}



# instanceof 연산자 : 만약 해당 클래스와 같은 상속 라인 위에 있을 경우 모두 같은 계열의 클래스로 인식
public class Person {}
public class Teacher extends Person {}
public class PartTimeTeacher extends Teacher {

    public static boolean checkInstanceOf(PartTimeTeacher partTimeTeacher ) {
        boolean ret = false;
        if (partTimeTeacher instanceof Teacher) { // True
            ret = true;
        }
        if ((partTimeTeacher instanceof Person) { // True
            ret = true;
        }
        return ret;
    }
}


# Base Entity Class : 실무에서 사용하는 모든 공통적인 속성(멤버변수, 메서드)를 묶어서 활용해 코드중복을 최소화 하기 위한 기본 클래스
=> 게임에서는 GameObject 클래스




# JAVA에서는 다중상속을 지원하지 않음(C++에서는 지원함)



# 다중상속의 문제점 : 가장 최하위 클래스는 최상위 클래스를 의도치않게 여러번 상속할 수 있어서 관리하는데에 오히려 더 복잡해질 수 있다.
(때문에 C++에서도 다중상속은 가급적이면 사용하지 말자!)



# 다중 상속이 발생하는 이유 : 하나의 클래스가 서로 다른 양상의 특징들을 상속받으려고 함
ex) 디지털 손목시계의 경우 '디지털'과 '손목에 건다'라는 서로 다른 양상의 특징들을 상속받으려고 하기 때문에 다중 상속 발생


# 다중 상속을 해결하는 방법
1) 추상화
2) 인터페이스 
=> 추상화 vs 인터페이스 



# 만약 Bird(새)클래스의 '날다(Fly)'라는 메서드가 있고, 이 Bird 클래스를 상속받는 비둘기, 독수리 등의 클래스의 경우엔 이 '날다'라는 메서드를 잘 쓸 수 있지만 한편으로는 Bird를 상속받으면서도 날지 못하는 '닭'클래스는 공통부분(날다)와는 괴리가 있는 특이한 경우이므로
이런 경우에는 중간 단계의 FlyingBird(나는 새)와 NonFlyingBird(날지 못하는 새) 클래스로 구분하고 '날다'라는 메서드는 FlyingBird에만 넣어주기



# 클래스를 재사용하면 좋은 점
1. 테스트에 걸리는 시간 절약 가능
- 하지만 이미 어느정도 테스트까지 끝낸 클래스라도 예전에 발견하지 못한 추가적인 버그 나올 수 있고, 
해당 클래스를 가져다 쓰면서 예상치 못한 버그 또한 발생할 수 있으므로 그에 대한 테스트도 필요.

2. 관리 비용 절약 가능
- 코드 중복이 없음 



# 상속 vs 컴포지션 선택 조건
- 둘다 재사용성을 위해 사용

1. 메모리 및 성능이 중요한 경우
: 상속의 경우 개체 생성시 메모리가 하나의 블록 단위 / 컴포지션의 경우 부품 개체 수만큼의 메모리 블록을 가짐
-> new 키워드 하나당 메모리 블록 하나에 대응
한편, 메인메모리에서 CPU의 캐시메모리로 데이터를 가져올 때 상속 모델로 만든 개체의 경우 메모리 블록이 하나이기 때문에 
데이터가 한 번에 캐시 메모리로 들어갈 확률이 높음(성능 향상)
반면, 컴포지션 모델로 만든 개체의 경우 관련된 메모리 블록이 여러개이기 때문에 개체 내 부품 수 만큼 캐시 메모리로 로딩될 가능성이 높음

또한, 상속은 메모리 할당과 해제가 딱 한번씩만 이루어지는 반면에 컴포지션은 한번 + 부품 수만큼씩 메모리 할당/해제가 이루어짐


2. 다형성이 중요한 경우 : 
ex) 여러 종류의 자식 개체들을 공통 부모형의 List에 담고 for문을 돌려 다형적인 작업을 할 경우


3. 상속은 부모가 가진 부분을 재사용 vs 컴포지션은 각 개체의 필요한 부분을 부품처럼 활용
깊은 상속보다는 컴포지션이 나을 수 있다!

4. 상속vs컴포지션이 헷갈리는 경우에는 해당 케이스가 여러 부품을 가지고 있는 특징이 강한지(컴포지션), 아니면 어느 특정 종류 중 하나인 케이스인지(상속) 구분하여 사용!



# 엔티티 컴포넌트 시스템 : 다양한 특성들을 부품(Component)들로 만들고, 그것을 가지고 조립해서 하나의 Object로 만들어 사용하는 방식
=> 깊은 상속에 대해 클래스들간의 상속 관계가 자주 바뀔 때 발생하는 문제 해결 가능!

class Object {
    ArrayList<Component> List; // Object 클래스는 여러 컴포넌트들로 구성됨
}

class Component {
}

 // 컴포넌트는 다음의 여러가지 특징을 가질 수 있음
class ControllableComponent extends Component {
}

class EntityComponent extends Component {
}

class PhysicsComponent extends Component {
}



# 다형성 : 같은 지시를 내렸는데 다른 종류의 개체가 동작을 달리하는 것
- 같은 지시 : 동일한 함수 시그니처 호출
- 동작을 달리하는 것 : 개체의 종류에 따라 실제로 실행되는 함수 구현 코드가 다름

즉, 부모와 자식이 동일한 함수 시그니처를 갖되, 자식단에서 해당 함수 내부 구현을 다르게 하는 것(->오버라이딩)이 다형성의 핵심
이를 통해 서로 다른 종류의 개체를 편하게 일괄적으로 저장 및 처리 가능
ex) 부모 형(type)을 저장하는 배열에 모든 자식 개체를 저장 가능



# 다형성의 예시(부모 형 변수에 자식 개체를 대입)
Animal animal = new Dog();  // Dog는 Animal을 부모로 가지고, shout() 메서드를 상속받아서 오버라이딩함
animal.shout(); 	// 부모 자료형 변수에 실제 자식 개체를 대입하고, 자식이 오버라이딩한 메서드를 호출하면 자식이 구현한 메서드로 호출됨

=> 이때, 만약에 shout()가 부모(Animal)에는 없고 자식(Dog)에만 선언된 메서드라면 부모형 변수에서 호출 불가능





# 오버라이딩 vs 오버로딩
- 오버라이딩 : 부모로부터 상속받은 메서드를 자식이 메서드의 내부 구현을 바꿈 
- 오버로딩 : 같은 메서드의 이름은 공유하나 매개변수의 타입, 길이 등은 서로 다르게 선언하는 기능



# 자식에서 오버라이딩을 통해 부모의 메서드의 구현을 변경하면서
동시에 해당 메서드의 부모의 구현 부분을 사용하려면 오버라이딩한 자식 메서드에서 "super.메서드명"으로 부모의 메서드 호출가능

public class Parent {
    public void print() {
        System.out.println("부모");
    }
}
public class Child extends Parent {
    public void print() {
        System.out.println("자식");
        super.print(); // 부모에서 구현된 print() 메서드 사용
    }
}



# 다형성의 장점
- 각 자료형의 코드가 클래스 안에 들어가있기 때문에 캡슐화 보장
- 새로운 클래스가 추가될 때마다 해당 클래스의 코드만 추가하면 되기 때문에 유지보수성이 높아짐



# 정적 바인딩 vs 동적 바인딩(늦은 바인딩)

- 정적 바인딩 : 어떤 함수 구현을 호출해야 하는지가 빌드 중(컴파일 타임)에 결정남(C언어, 단 함수포인터는 늦은 바인딩)
=> 따라서 함수 호출문을 곧바로 어셈블리어의 jmp 명령어로 교체 가능하며, 
jmp하는 주소는 해당 함수의 어셈블리어 코드가 시작하는 메모리 주소
그리고 함수 호출이 끝나면 이전 코드 위치로 다시 돌아옴


- 동적 바인딩 : 어떤 함수 구현을 호출해야 하는지가 실행 중(런타임)에 결정남(JAVA)
public void mothod(Animal animal) { // Animal 클래스를 상속받는 두 자식 클래스 Dog와 Cat이 있다고 할 때,
    animal.shout(); // 이 메서드를 호출하는 실제 개체가 Dog인지, Cat인지, 아니면 부모인 Animal인지 컴파일 타임에는 알 수 없음
}

=> 즉, JAVA의 상속 및 다형성에서는 실제 호출되는 메서드의 구현 부분이 런타임에 결정됨.



# C에 없는 기능은 하드웨어에 없으며, JAVA에서 지원하는 기능은 사실은 C의 기능들을 조합해서 만든 것
-> 결국 자바의 다형성도 C언어의 함수포인터를 활용해서 구현했으며, C언어의 함수포인터는 동적 바인딩이기 때문에
자바에서의 다형성도 동적 바인딩이다!



# 정적 바인딩(이른 바인딩) vs 동적 바인딩(늦은 바인딩) 성능 비교
: 정적 바인딩의 경우 컴파일러가 실제로 어떤 함수를 호출해야 되는지 알 수 있기 때문에
 컴파일 시간동안 충분한 시간을 들여 최적화를 할 수 있으며, 실행 중에는 이렇게 최적화를 할 수 있는 시간적 여유가 없음.



# JAVA에서의 이른 바인딩과 final 키워드
 : 메서드 앞에 final 키워드를 붙이면 자식에서 오버라이딩이 불가능하며,
이를 통해 컴파일러는 해당 메서드는 실행 중이 아닌, 컴파일 타임에 해당 메서드의 구현 부분을 결정할 수 있음 -> C의 함수 호출과 동일하게 동작
즉, final 키워드를 통해 JAVA에서도 이른 바인딩 가능



정리하면, C언어에서의 함수 호출은 기본적으로 정적 바인딩(이른 바인딩)이되, 함수 포인터를 통해 동적 바인딩(늦은 바인딩) 사용 가능
JAVA에서의 함수 호출은 기본적으로 동적 바인딩, 한편 final 키워드를 통해 정적 바인딩 사용 가능



# final 키워드 의미
 - 변수 앞에 붙을 경우 : 더 이상 변수 값을 변경하지 못함
 - 메서드 앞에 붙을 경우 : 자식 클래스에서 해당 메서드를 오버라이딩 하지 못함
 - 클래스 앞에 붙을 경우 : 해당 클래스를 상속하지 못함. 즉, 자식 클래스가 존재할 수 없고, 따라서 오버라이딩도 할 수 없음



# Best Practice : final은 기본적으로 붙이되, 나중에 변경 및 상속이 필요한 경우가 생기면 그때 final을 뺀다.
-> 실무에서 사용하는 클래스의 대부분은 상속을 사용하지 않기 때문



# equals() 메서드 : 
기본적으로 자바에서 == 비교연산자의 경우 두 개체의 주소값을 기준으로 비교
Object 클래스의 equals() 메서드도 기본적으로는 == 비교연산자처럼 두 개체의 주소값을 기준으로 비교(this == object)하지만,
단순 주소 비교가 아니라 클래스 내의 데이터 비교를 통해서 결정해야 한다면 이 equals() 메서드를 오버라이딩 해서 사용하기
=> 한편, equals() 메서드를 오버라이딩하면 이와 함께 hashcode() 메서드도 반드시 같이 오버라이딩해서 해당 클래스 비교에 맞게 별도로 정의해줘야 함

// Person 클래스의 equals 메서드 오버라이딩 예시
public boolean equals(Obejct obj) {
    if (obj == this) { 
        return true; // obj가 자신과 같다면 true 리턴
    }
    if (obj == null || !(obj Instanceof Person)) {
        return false; // obj가 null이거나, 아예 다른 클래스라면 false 리턴
    }
    
    // Person 클래스 특성에 맞게 오버라이딩 구현
    Person person = (Person)obj;
    ...
}




# 추상 클래스
- 다형성의 문제점 1 : 부모로부터 상속받은 메서드를 특정 자식에서 마음대로 구현을 안해버릴 수도 있으며, 이로 인해 부모 클래스를 설계하면서 의도했던 기능이 나오지 않을 수도 있는 문제점이 있음
- 다형성의 문제점 2 : Human, Animal 처럼 구체적인 특성을 가진 자식 클래스들의 공통 분모만 뽑아내서 분류하고 실제로 개체 생성은 안할 클래스들의 경우, 
그 설계 의도와는 맞지 않게 실제로는 언제든 해당 클래스들의 개체를 생성할 수도 있다는 문제가 있음

즉, 부모로부터 상속받은 메서드를 자식이 반드시 구현하도록 하고
자식들의 공통 분모만 뽑아내서 분류한 클래스의 인스턴스 생성을 막고 싶음

=> 추상 클래스(abstrack class) 사용

public abstract class Monster{ // 추상 클래스로 선언하였으며, 이로 인해 Monster 클래스의 개체 생성 불가
    public abstract int attack(Monster target); // 자식들은 이러한 추상 메서드인 attack 메서드를 반드시 오버라이딩 해야 함(안그러면 컴파일 오류)
}

- 추상 클래스라 하더라도 반드시 추상 메서드만 있지는 않아도 됨
- 단, 추상 메서드가 있다면 그 클래스는 반드시 추상 클래스로 선언되어야 함

ex) BaseEntity 클래스




# 인터페이스(Interface) : 오로지 함수의 시그니처(반환 타입, 함수명, 매개변수)만 있고 상태나 함수의 구현이 없는 순수 추상 클래스로, 
 해당 인터페이스를 구현(implements)하는 클래스에서 그 함수들을 직접 구현함.
- 추상 클래스처럼 인터페이스에서 선언된 메서드들도 implements하는 클래스에서 모두 구현을 안하면 컴파일 오류
  => 덕분에 상속받은 메서드명을 실수로 오타내거나 부모클래스에서 선언된 메서드명을 바꾸고나서 실수로 자식에서는 바꾸지 않은 경우 발생할 수 있는 문제 예방 가능
- 인터페이스는 무조건 public이며(public 키워드 생략해도 public), 인터페이스 내 메서드도 별도로 public 키워드를 붙이지 않아도 모두 자동으로 public
- 인터페이스는 무조건 같은 패키지 안에서만 import해서 사용 가능 
- 인터페이스는 다중 상속이 가능




# 추상 클래스(Human)를 인터페이스로 바꿔보기
: 추상 클래스와 인터페이스는 실직적으로 같은 기능(동작의 선언과 구현을 분리) 제공

public abstract class Human { 
    public abstract void talk(String msg);
}

public class Teacher extends Human { // Teacher 클래스가 추상 클래스인 Human을 상속
    public void talk(String msg) {
        ...
    }
}

=>

public interface IHuman { // 인터페이스명 앞에는 'I'를 붙여서 클래스와 구분해주자!
    void talk(String msg); // 인터페이스의 메서드는 언제나 public
}

public class Teacher implements IHuman { // Teacher 클래스가 인터페이스인 IHuman을 구현
    public void talk(String msg) {
        ...
    }
}




# JAVA 어노테이션 : 메서드 위에 @Override, @Deprecated 와 같은 표기를 함으로써 컴파일러 및 해당 코드 사용자에게 프로그래머의 의도를 전달하고,
컴파일/빌드 중에 사용한 어노테이션 기반으로 관련된 처리를 쉽게 할 수 있음

@Deprecated : 해당 메서드는 언젠가 지원이 끊길 예정
@Override : 해당 메서드는 부모로부터 상속받아 오버라이드함

ex) 
public class Teacher extends Human {
    @Override // Human 클래스로부터 상속받은 talk 메서드를 오버라이드 한다고 표기
    public void talk(String msg) { // 만약 @Override 메서드와 맞는 함수 시그니처가 부모에 없으면 컴파일 오류
        ...
    }
}




# 인터페이스와 다중상속 : 인터페이스는 다중 상속(implements) 가능 (인터페이스 implements와 클래스 상속은 사실상 같은 기능이라고 보면 됨)
 - 이미 각각 구현이 된 동일 메서드 시그니처를 가진 여러 클래스를 상속받는 경우엔, 자식이 어느 부모의 메서드를 상속받아야 하는지 명확하지 않기 때문에 이러한 다중 상속은 불가능하지만, 
인터페이스의 경우엔 구현은 없고 오로지 메서드 시그니처만 있기 때문에 implements하는 클래스가 그 중 하나의 메서드 시그니처만 가져와서 구현하면 됨.
 - 단, 다중 implements하는 인터페이스들의 메서드 시그니처가 메서드명과 매개변수가 같지만 반환형이 다른 경우엔 메서드 오버로딩이 불가능하므로 이런 경우엔 다중 implements 불가


ex)
public interface IHuman {
    void walk();
    int getWeight();
}

public interface IAminmal {
    void walk();
    float getWeight();
}

public class HumanAndAnimal implements IHuman, IAnimal { // HumanAndAnimal이 IHuman과 IAnimal 인터페이스 다중상속받아서 구현
    void walk(); // 어차피 구현은 HumanAndAnimal에서 하기 때문에 IHuman과 IAnimal의 동일 시그니처 메서드 중 아무 walk()를 가져와도 문제 발생 X
    int getWeight(); // 메서드명과 매개변수가 같지만 반환형이 다른 경우에는 오버로딩이 불가능하기 때문에 이런 경우도 불가능
}

 - 여러 인터페이스를 implements한 경우, 그 인터페이스들의 메서드 시그니처를 모두 구현해야 하며, 안그러면 컴파일 오류





# 즉, 인터페이스의 핵심은 1)함수 포인터처럼 메서드의 선언과 구현을 분리 가능, 2)다중 상속 가능




# 인터페이스 vs 추상 클래스
 - 인터페이스는 다중 상속 지원
 - 추상 클래스는 단일 상속만 지원하고, 자식 클래스들의 공통된 멤버(변수, 메서드)들을 통합 및 확장 가능




# Object.clone() : 클래스 복사 메서드
대입자로 복사할 경우엔 단지 클래스 객체의 주소만 복사할 뿐,
진짜 클래스 자체의 복사를 원할 경우엔 
아래와 같이 Clonable 인터페이스를 상속(implements)받은 후 Object.clone() 메서드를 직접 구현해야 함.

/* 얕은 복사 */
public final class Robot implements Clonable {
    ...
    public Object clone() throws CloneNotSupportedException {
        /* 
	해당 객체가 가지고 있는 값을 복사한 객체에 대입해줌
            단, 이런 경우 값형 변수의 경우엔 문제가 없지만, 
            클래스같은 참조형 변수의 경우엔 기존 객체에 포함된 참조형 변수가 가리키는 주소를 복사해서 대입(얕은 복사)하기 때문에
            깊은 복사를 하기 위해선 추가적인 작업이 필요함 
        */
        return super.clone(); 
    }
}

/* 깊은 복사 */
public final class Head implements Clonable { 
    /*
        Robot에 포함되어 있는 Head 클래스형 변수에 대해서도 깊은 복사를 지원하기 위해
        Head 클래스도 Clonable 상속 후 clone() 메서드 구현 필요
    */
    ...
    // 만약 Clonable 인터페이스를 상속받지 않고 clone() 메서드를 오버라이딩 하면 CloneNotSupportedException 예외 발생
    public Object clone() throws CloneNotSupportedException { 
        return super.clone(); 
    }
}

public final class Robot implements Clonable {
    private Head head = new Head();
    ...
    public Object clone() throws CloneNotSupportedException {
        Robot cloned = (Robot)super.clone();
        cloned.head = (Head)head.clone();

        return cloned;
    }
}



# 복사생성자 : C++에서 지원하는 방식으로, 깊은 복사가 가능
public final class Point {
    private int x;
    private int y;

    public Point(final int x, final int y) {
        this.x = x;
        this.y = y;
    }

    public Point(Point other) {
        this(other.x, other.y);
    }
}

public final class Line {
    private Point p1;
    private Point p2;

    public Line(Point p1, Point p2) {
        this.p1 = p1;
        this.p2 = p2;
    }
    
    /* 복사 생성자를 통한 깊은 복사 진행 */
    public Line(Line other) {
        this(new Point(other.p1),
                new Point(other.p2));
    }
}


# 구체 클래스 vs 인터페이스(=순수 추상 클래스)
- 구체 클래스 : 상태와 동작을 모두 포함 / 동작에 다양한 접근권한 부여 가능 / 개체 생성 가능 / 다중 상속 불가
- 인터페이스 : 동작에 대한 선언만 포함 / 모든 동작은 public / 개체 생성 불가 / 다중 상속 가능



# 의존성(Dependency) : 클래스 A가 제대로 동작하려면 클래스 B가 반드시 필요한 경우 -> A는 B에 의존한다

=> 의존성이 있어야 좋은 설계다
- 각 클래스마다 목적이 뚜렷하다는 의미
- 캡슐화가 잘 되어있다는 의미
- 클래스를 재사용할 수 있다는 의미



# 결합도 : A가 B에 의존하는 상황에서 B를 변경할 때, A에 영향이 얼마나 가는지
- A의 내부를 변경하지 않아도 된다 : 결합도가 낮음
- A의 내부를 변경해야만 제대로 동작 : 결합도가 높음



# 결합도 낮추는 방법 : 의존성 주입(DI)

public final class Robot {
    private int hp;
    private Head head; // Head 클래스에 의존

    /* 이렇게 Head 클래스자체를 매개변수로 받음으로써 Head 클래스 내부의 변화에 대해 Robot 클래스가 받는 영향도를 줄임 */
    public Robot(int initialHp, Head head) { 
        this.hp = initialHp, ;
        this.head = head; // 생성자를 통해 주입(생성자 주입)
    }

    public void setHead(Head head) { // Setter를 통한 주입
        this.head = head;
    }
}

=> 이때 가급적이면 다형성을 사용해서 인터페이스/추상 클래스에 대해 의존성 주입을 활용하면 결합도가 많이 낮아짐
ex) Head의 자식 클래스들인 SimpleHead, SmartHead 등이 있어도 Robot 클래스에서는 Head 클래스 형으로 의존성 주입을 받으면
Robot 클래스 소스를 고치지 않고도 Head의 자식들을 모두 활용 가능함



# 디커플링(결합도를 낮춤) : 추상화와 마찬가지로 유연성과 재사용성을 높임



# [참고사항]
 Collection<> 인터페이스 : 데이터를 저장하는 컬렉션 클래스들(ArrayList, Set, Map 등)이 구현하는 인터페이스

ex)
import java.util.Collection;

public final class DataSource {
    ...
    public void MergeTo(Collection<Data> dataset) {
    } // 소스로부터 모든 데이터를 얻어와 중복 없이 dataset에 넣는다
}

=> Datasource.MergeTo() 메서드 : DataSource 개체가 가지고 있는 모든 데이터를 dataset에 추가(단, 중복이 없어야 함)




# 추상화, 디커플링을 통해 유연성 및 재사용성이 높아질수록 점점 일반적이게 되므로 반대로 직관성/명확함, 효율성이 떨어지게 되는 단점이 있음
- ex1) 타입이 부모 클래스여서 런타임때 실제로는 어떤 자식 클래스가 사용될지 구체적으로 알 수 없음
- ex2) 특정 자식 클래스가 가진 특성이 아닌, 모든 자식 클래스의 공통적인 특성에 맞는 방식을 해당 특정 클래스에 적용해야 되는 경우가 있음



# 인터페이스의 잘못된 사용 : 인터페이스와 구체 클래스의 비율이 1:1인 케이스
즉, 다형성이 필요한 여지가 없는데 굳이 인터페이스를 사용한 경우



# 결국 제일 중요한 것은 한쪽으로 극단적으로 치우치지 않고
유연성/재사용성과 명확성/효율성 사이에서 타협점을 찾는 것



# 실용적인 인터페이스 사용법
- 기본적으로 클래스를 사용
- 단, 함수포인터같은 기능이나 다형성 있는 다중 상속이 필요한 경우에는 인터페이스 사용
- 또한, 내 소스를 사용하는 클라이언트가 같은 팀이 아닌 외부 사람일 경우에는 변화에 따른 영향도를 최소화하기 위해 인터페이스 사용



# 디자인 패턴 : 단지 문제 해결 관련 가이드일 뿐, 디자인 패턴 자체가 문제를 해결해 주지는 않음
- 디자인 패턴 배웠다고 해서 절대 바로 사용하려고 하지 않기(코드가 이상해진다!)
- 해당 패턴을 딱 봤을 때 코드가 익숙하면 그때가 바로 디자인 패턴을 스스로 적용해볼 수 있는 시기(패턴을 처음 봤을 때 익숙하지 않다면 그 문제를 못 접해봤고, 그 해법도 고민을 못해봤다는 의미)



# 추상화 팁 : 처음부터 추상적인 패턴을 사용하지 말고, 구체적인 것에서부터 시작해서 필요한 만큼까지만 추상화 하자



# 팩토리 메서드 패턴 : 사용할 클래스 정보를 정확히 몰라도 개체 생성을 가능하게 해주는 패턴

public enum CupSize {
    SMALL,
    MEDIUM,
    LARGE
}

public final class Cup {
    private int sizeMl;

    private Cup(int sizeMl) { // 생성자는 private
        this.sizeMl = sizeMl;
    }

    // 생성자 대신 size에 맞는 컵을 알아서 생성 후 리턴해줌
    public static Cup createOrNull(CupSize size) {
	switch (size) {
	    case SMALL:
		return new Cup(355);
	    case MEDIUM:
		return new Cup(473);
	    case LARGE:
		return new Cup(651);
	    default:
		assert (false) : "Unhandled CupSize:" + size;
		return null;
	}
    }
}

=> 생성자의 경우는 반환하는 것이 없기 때문에 개체 생성시 문제가 생길 경우 오직 예외를 던지는 방법밖에 없지만,
이러한 팩토리 메서드 패턴은 개체 생성때 문제가 생기면 null을 반환 가능하다는 장점이 있음.

여기에 다형성을 적용해보면 Cup 클래스를 추상 클래스로 바꾸고, 이를 상속하는 PaperCup이나 PlasticCup 클래스를 자식으로 만들어서
각 클래스 성격에 맞는 createOrNull 메서드를 오버라이딩하여 사용하면 됨.



# 빌더 패턴 : StringBuilder처럼 해당 개체의 부분부분을 만들어 나가다가 준비가 되면 그 때 해당 개체를 완성(.toString())시켜 생성
- 플루언트 인터페이스 : builder.append(heading)
                              .append('\n')
                              .append('\n');
처럼 append에서 자기 자신을 리턴하여 계속 이어붙여 나가는 방식



# 래퍼/어댑터 패턴 : 어떤 클래스의 메서드 시그내처가 맘에 안 들 때, (해당 클래스에 의존하는 다른 클래스에 영향도를 없애기 위해서) 
그 클래스의 메서드 시그내처를 바꾸는 대신 새로운 클래스를 만들어 기존 클래스를 감싸는 방법


# 래퍼/어댑터 패턴 사용 이유
- 추후 내부에서 변동사항이 생길 때 클라이언트 코드를 변경하지 않기 위해 
- 사용중인 외부 라이브러리가 우리의 코딩 표준과 맞지 않을 때
- 기존 클래스에 없는 기능을 추가하려고 하는데, 기존 클래스에 추가하기에는 어렵고 아예 새로운 클래스를 별도로 만들기에는 좀 애매하다 싶으면 기존 클래스를 감싸는 새로운 클래스를 만들고, 그 새로운 클래스에 새로운 기능을 추가함. 그리고 기존 클래스를 사용하기 위해서는 반드시 새로운 클래스를 통해서만 사용 가능하게끔 함
- 내부 개체를 클라이언트에 노출시키지 않기 위해(ex. DTO)



# 클라이언트 코드를 변경하지 않기 위해 래퍼/어댑터 패턴 사용 예시

/* OpenGL의 화면을 clear시키는 메서드(clearScrean)를 Graphics 클래스로 감쌈 */
public final class Graphics {
    private OpenGL gl;

    public void clear(float r, float g, float b, float a) {
        this.gl.clearScrean(a, r, g, b); // OpenGL에서 화면을 clear시키는 메서드
    }
}

만약에 기존 OpenGL에서 DirectX로 바꾸고 싶다면?

/* 코드 두 줄만 수정하면 클라이언트 코드 수정 없이 OpenGL -> DirectX로 손쉽게 전환 가능 */
public final class Graphics {
    // private OpenGL gl;
    pviate DirectX dx; // OpenGL 클래스는 주석처리하고 새로 DirectX 클래스 선언

    // DirectX에서 화면을 clear시키는 메서드로 전환
    public void clear(float r, float g, float b, float a) {
       // this.gl.clearScrean(a, r, g, b); // OpenGL에서 화면을 clear시키는 메서드를 주석 처리
           this.dx.clear((int)(r * 255), (int)(g * 255), (int)(b * 255), (int)(a * 255)); 
    }
}



# 래퍼 패턴과 DTO
- 클라이언트가 필요한 데이터만을 별도의 데이터 전송만을 위한 DTO클래스에 담아서 전달
 => 클라이언트에 굳이 필요 없는 데이터를 보내지 않을 수 있고, 보안상의 이점도 있음



# 프록시 패턴(지연 로딩 + 캐싱) : 시간이 오래 걸리는 특정 작업을 클래스가 해야 될 때(ex. 용량이 큰 파일 데이터 읽어오기), 
개체 생성 시에는 파일 경로 같은 해당 작업을 수행하기 위해 필요한 정보만 저장해 두었다가
실제 클라이언트가 해당 작업을 요청할 때 수행하고, 그 작업을 수행하면서 불러온 큰 데이터가 있다면 그 데이터를 캐싱해 둠
따라서 이후에 해당 작업이 또 수행하게 되면 다시 큰 데이터를 불러오지 않고 캐싱해 둔 데이터 사용



# 프록시 패턴 사용시 주의할 점
- 만약 최신의 데이터가 필요하다면 지연 로딩보다는 즉시 로딩 사용
- 메모리 사용량을 최소화 해야한다면 지연 로딩하되, 캐싱하지 않는 것이 효율적

=> 결국 이런 케이스에는 클라이언트가 상황에 맞게 직접 클래스의 즉시로딩/지연로딩/캐싱 동작을 파악하고 사용할 수 있도록 하는 것이 중요!
=> 즉, 작업 수행의 캡슐화를 통해 클라이언트가 내부 동작을 모르던 것을 세분화하여
데이터를 읽어왔는지 확인(isLoaded), 데이터를 즉시 로드(load), 데이터 저장(save), 데이터 언로드(unload)로 구분하고
클라이언트가 상황에 맞게 이 구분된 메서드들을 활용하여 지연로딩/즉시로딩/프록시 패턴을 사용하도록 하는 것이 올바른 방식!

 

# 책임 연쇄 패턴 : 어떤 작업을 수행하는 여러 개체가 있을 때, 그 개체들은 해당 작업을 수행할 수 있는 기회를 차례로 부여 받음
만약 그중 한 개체가 그 작업을 수행완료하면 그에 대한 책임을 지고, 해당 작업 프로세스를 바로 종료해버림으로써 다음 차례 개체들은 작업 수행 기회를 부여받지 않음
- ex) LogLevel(INFO, DEBUF, ERROR)에 따른 로그 출력 내용 단계 등 



# Pub-Sub 패턴
발행자(Publisher)가 있고 그 발행자의 상태가 변할때 특정 작업을 수행해야 되는 구독자(Subscriber)가 있는 패턴으로,
주로 발행자와 구독자는 다대다 구조를 이루며 그 중간에서 발행자와 구독자 사이를 조율하는 Manager 클래스가 있음
- 메모리 누수 관련 이슈 : Maganer 클래스에 ArrayList로 pub과 sub 객체를 담아서 관리하는 상태일 때 sub 하나가 구독을 취소하면 반드시 Manager 클래스의 ArrayList에서 해당 sub 객체를 remove 시켜줘야 함. 만약 그렇지 않으면 ArrayList에서 여전히 구독을 취소한 sub을 참조하고 있기 때문에 GC에서 해당 객체를 정리하지 않음!










