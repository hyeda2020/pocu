# 4. 다형성
- **다형성** : 같은 지시를 내렸는데 다른 종류의 개체가 동작을 달리하는 것.
  - 같은 지시 : 동일한 함수 시그니처 호출.
  - 동작을 달리하는 것 : 개체의 종류에 따라 실제로 실행되는 함수 구현 코드가 다름.

  즉, 부모와 자식이 동일한 함수 시그니처를 갖되, 자식단에서 해당 함수 내부 구현을 다르게 하는 것(오버라이딩)이 다형성의 핵심.  
  이를 통해 서로 다른 종류의 개체를 편하게 일괄적으로 저장 및 처리 가능.  
  ex) 부모 형(type)을 저장하는 배열에 모든 자식 개체를 저장 가능.


- **다형성의 예시(부모 형 변수에 자식 개체를 대입)**  
  ```
  Animal animal = new Dog();  // Dog는 Animal을 부모로 가지고, shout() 메서드를 상속받아서 오버라이딩함
  animal.shout(); 	// 부모 자료형 변수에 실제 자식 개체를 대입하고, 자식이 오버라이딩한 메서드를 호출하면 자식이 구현한 메서드로 호출됨
  // 이때, 만약에 shout()가 부모(Animal)에는 없고 자식(Dog)에만 선언된 메서드라면 부모형 변수에서 호출 불가능
  ```
  
- **오버라이딩 vs 오버로딩**
  - 오버라이딩 : 부모로부터 상속받은 메서드를 자식이 메서드의 내부 구현을 바꿈.
  - 오버로딩 : 같은 메서드의 이름은 공유하나 매개변수의 타입, 길이 등은 서로 다르게 선언하는 기능.
  ```
  /* 
    자식에서 오버라이딩을 통해 부모의 메서드의 구현을 변경하면서
    동시에 해당 메서드의 부모의 구현 부분을 사용하려면 
    오버라이딩한 자식 메서드에서 "super.메서드명"으로 부모의 메서드 호출가능
  */
  public class Parent {
      public void print() {
          System.out.println("부모");
      }
  }
  public class Child extends Parent {
      public void print() {
          System.out.println("자식");
          super.print(); // 부모에서 구현된 print() 메서드 사용
      }
  } 
  ```
  
- **다형성의 장점**
  - 각 자료형의 코드가 클래스 안에 들어가있기 때문에 캡슐화 보장.
  - 새로운 클래스가 추가될 때마다 해당 클래스의 코드만 추가하면 되기 때문에 유지보수성이 높아짐.


- **정적 바인딩 vs 동적 바인딩(늦은 바인딩)**
  - 정적 바인딩 : 어떤 함수 구현을 호출해야 하는지가 빌드 중(컴파일 타임)에 결정남(C언어, 단 함수포인터는 늦은 바인딩)  
    => 따라서 함수 호출문을 곧바로 어셈블리어의 jmp 명령어로 교체 가능하며,  
    jmp하는 주소는 해당 함수의 어셈블리어 코드가 시작하는 메모리 주소.  
    그리고 함수 호출이 끝나면 이전 코드 위치로 다시 돌아옴.
  - 동적 바인딩 : 어떤 함수 구현을 호출해야 하는지가 실행 중(런타임)에 결정남(JAVA).
    ```
    // Animal 클래스를 상속받는 두 자식 클래스 Dog와 Cat이 있다고 할 때,
    public void mothod(Animal animal) { 
        // 이 메서드를 호출하는 실제 개체가 Dog인지, Cat인지, 아니면 부모인 Animal인지 컴파일 타임에는 알 수 없음
        animal.shout(); 
    } 
    ```
    즉, JAVA의 상속 및 다형성에서는 실제 호출되는 메서드의 구현 부분이 런타임에 결정됨.
  - ※ C언어에 없는 기능은 하드웨어에 없으며, JAVA에서 지원하는 기능은 사실은 C의 기능들을 조합해서 만든 것.  
    결국 자바의 다형성도 C언어의 함수포인터를 활용해서 구현했으며, C언어의 함수포인터는 동적 바인딩이기 때문에  
    자바에서의 다형성도 동적 바인딩이다!


- **정적 바인딩(이른 바인딩) vs 동적 바인딩(늦은 바인딩) 성능 비교**  
  정적 바인딩의 경우 컴파일러가 실제로 어떤 함수를 호출해야 되는지 알 수 있기 때문에  
  컴파일 시간동안 충분한 시간을 들여 최적화를 할 수 있으며, 실행 중에는 이렇게 최적화를 할 수 있는 시간적 여유가 없음.


- **`final` 키워드**
  - 변수 앞에 붙을 경우 : 더 이상 변수 값을 변경하지 못함.
  - 메서드 앞에 붙을 경우 : 자식 클래스에서 해당 메서드를 오버라이딩 하지 못함.
  - 클래스 앞에 붙을 경우 : 해당 클래스를 상속하지 못함. 즉, 자식 클래스가 존재할 수 없고, 따라서 오버라이딩도 할 수 없음.


- **JAVA에서의 이른 바인딩과 final 키워드**   
  메서드 앞에 `final` 키워드를 붙이면 자식에서 오버라이딩이 불가능하며,  
  이를 통해 컴파일러는 해당 메서드는 실행 중이 아닌, 컴파일 타임에 해당 메서드의 구현 부분을 결정할 수 있음.  
  -> C의 함수 호출과 동일하게 동작.  
  즉, final 키워드를 통해 JAVA에서도 이른 바인딩 가능.


- **`final` 키워드 Best Practice**    
  실무에서 사용하는 클래스의 대부분은 상속을 사용하지 않기 때문에  
  `final`은 기본적으로 붙이되, 나중에 변경 및 상속이 필요한 경우가 생기면 그때 `final`을 뺀다.


- **`equals()` 메서드**  
  기본적으로 자바에서 == 비교연산자의 경우 두 개체의 주소값을 기준으로 비교.  
  Object 클래스의 `equals()` 메서드도 기본적으로는 == 비교연산자처럼 두 개체의 주소값을 기준으로 비교(this == object)하지만,  
  단순 주소 비교가 아니라 클래스 내의 데이터 비교를 통해서 결정해야 한다면 이 `equals()` 메서드를 오버라이딩 해서 사용하기.  
  => 한편, `equals()` 메서드를 오버라이딩하면 이와 함께 `hashcode()` 메서드도 반드시 같이 오버라이딩해서 해당 클래스 비교에 맞게 별도로 정의해줘야 함.