# 클래스

- **개체** : 상태 + 동작 = (데이터 + 메서드)  
  이때, 자바에서 개체는 C++에서의 레퍼런스이며(C에서의 포인터),  
  즉 참조형이기 때문에 메서드 안에서 개체의 멤버변수 값을 바꾸면 메서드 밖의 원본에도 영향을 미침.  
  또한, 개체는 포인터이기 때문에 모두 동적으로 할당(new 키워드)되며, 힙 메모리에 저장됨.  
  (단, 일반 자료형(int, float, double) 변수는 스택 메모리에 저장됨)

  
- **생성자** : 개체가 생성과 동시에 올바른 상태임을 보장해주는 일종의 함수.  
  즉, 콜라를 샀는데 캔 내부에 내용물이 비어있을 가능성이 없다는 것을 보장해줌.  
  이러한 생성자를 활용하면 개체의 멤버변수를 초기화하는 코드의 중복을 막아주고,  
  덕분에 멤버변수가 추가/제외되어도 개체를 초기화하는 데에 있어서 프로그래머의 실수를 줄여줌.  


※ 객체 생성시 따로 지정하지 않아도 멤버변수는 자동으로 int형은 0, float는 0.0, 그 외 참조형은 null로 초기화가 됨.
  
- **생성자와 매개변수** : 매개변수가 있는 생성자가 정의되어 있을 경우,  
  매개변수가 없는 생성자도 추가로 정의해주지 않으면  
  컴파일러가 자동으로 제공해주던 매개변수가 없는 생성자는 사용 불가
    ```
    public class Human {
        ...
        public Human(int a) // 매개변수가 있는 생성자만 존재
        {
            ...
        }
        ....
    }

    ...
    public static void main(String[] args) {
        Human h = new Human();  // 컴파일 오류
        ...
    } 
    ```
  

- **`this()`** : 같은 클래스의 다른 생성자를 코드 중복 없이 편하게 호출  
    ```
    public class Human {
        String name;
        int age;
        int a;

        public Human(String name, int age) {
            // 코드 중복 발생
            this.name = name;
            this.age = age;
        }

        public Human(String name, int age) {
            // this() 키워드를 통해 같은 클래스의 다른 생성자를 코드 중복 없이 편하게 호출
            this(name, age); // 생성자 코드의 가장 위에 있어야 함
            //this.age = 0;
        }
    }
    ```
  
- **접근제어(`public`/`private`)**
  - 클래스/개체는 자신의 상태를 사람이 아닌, 클래스/개체 스스로가 책임지도록 만들어야 함.  
    즉, 개체 외부에서 개체의 상태에 직접 접근하는 것을 막아야 하며,  
    개체의 상태는 오로지 개체 자신만 바꿀 수 있어야 함.  
    => private / Getter / Setter 활용.  

  - 일반적으로 클래스 선언에 대한 접근제어자는 public, 혹은 접근제어자 생략만 가능하지만,  
    클래스 안에 정의된 또 다른 클래스, 즉 내포클래스의 경우에는 private, protected도 사용 가능.  

  - 메서드는 보통 public으로 선언하지만, 멤버 변수는 private로 하고 메서드를 통해서만 접근 가능하게끔 하는 것이 일반적.  
    => 캡슐화, 데이터 추상화  
    단, 메서드를 private로 선언하는 경우에는 주로 코드 중복을 피할 목적으로 해당 메서드를 클래스 내부에서만 사용하기 위함.  

  - 이때, 내부란 개체의 내부가 아니라 클래스의 내부를 의미함.   
    즉, 같은 클래스라면 서로 다른 개체는 서로의 내부에 접근 가능!  
  
  
- **Getter/Setter**  
  직접 멤버변수에 접근하지 않고 getter/setter 메서드를 사용할 때의 장점은
  getter/setter내에 Validation Check 등의 추가적인 로직 포함 가능하다는 것이며,
  상속을 통한 다형성 구현 가능. 
  - getter는 자유롭게 추가하되, 레퍼런스 타입(주로 클래스)인 경우에는 getter로 리턴되고 나서 외부에서 값을 수정할 경우,  
    내부에도 영향을 미치기 때문에 이런 경우에는 조심하기.
  - setter는 무조건 넣지 말고, 변경되면 안되는 멤버변수일 경우에는 setter는 추가하지 않기.  

  
- **접근제어와 캡술화, 추상화**  
  - 캡슐화 : 개체의 데이터(멤버 변수)와 동작(메서드)를 하나로 묶고, 내부의 데이터를 외부로부터 보호.  
  (마치 사용자가 함수 속이 어떻게 구현되어있는지 알 필요가 없는 것처럼 외부에서 클래스 내부를 알 필요가 없음)  
  - 추상화 : 구체적인 내부(private 멤버 변수)에 직접 접근하지 않음.

  
- **개체 모델링 시 유의점**
  1. 한번에 모든 것을 다 완벽하게 담으려고 하지 말고, 그때그때 필요할 때마다 코드를 추가하는 것이 좋음.  
     (즉, 많은 내용으로 시작했다가 변경사항이 생겨서 나중에 한꺼번에 뒤엎기 보다는, 단순하게 시작해서 점점 살을 붙여가는게 좋음)
  2. 유연성이 높다(=코드 재사용성이 높다)고 해서 무조건 좋은 것은 아님.  
     유연성을 높이려면 클래스를 잘게 쪼개는 과정이 필요한데, 이로 인해 오히려 복잡성이 크게 증가할 수 있으며,  
     성능 저하 및 가독성이 떨어질 수 있음. 즉, 정말 자주 사용하는 것에 대해서만 유연성을 높이기  


- **※ 함수 사용 팁**
  1. 함수는 가급적이면 여러 동작을 하기 보다는 명백한 하나의 동작을 하는게 좋음. 
  2. 함수가 특정 작업을 수행하고, 그 작업과 관련 없는 값을 리턴하는 것은 직관적이지 않고 명백하지 않지만  
     함수에서 특정 작업을 수행하고, 그 결과의 성공 여부를 boolean 타입으로 반환(성공하면 true, 실패하면 false) 하는 정도는  
     성공여부를 확인할 필요가 있는 경우에 대해선 나름 합리적.
  3. 특정 함수가 Null을 리턴할 수 있으면 함수명에 OrNull을 붙이기  
     특정 변수가 Null값일 수 있으면 변수명에 OrNull을 붙이기


- **※ 정리 : 결국 중요한건 기본기**
  1. 우선 기본기부터 확실히 잡기
  2. 읽기 명확한 코드 만들기
  3. 실수를 저지르기 어려운 코드 만들기
  4. 문제를 해결하는 코드 만들기
  5. 문제가 생기면 디버깅하기