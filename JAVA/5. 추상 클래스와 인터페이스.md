# 5. 추상 클래스와 인터페이스

- **추상 클래스**
  - 다형성의 문제점 1 : 부모로부터 상속받은 메서드를 특정 자식에서 마음대로 구현을 안해버릴 수도 있으며,   
    이로 인해 부모 클래스를 설계하면서 의도했던 기능이 나오지 않을 수도 있는 문제점이 있음.  
  - 다형성의 문제점 2 : Human, Animal 처럼 구체적인 특성을 가진 자식 클래스들의 공통 분모만 뽑아내서 분류하고   
    실제로 개체 생성은 안할 클래스들의 경우, 그 설계 의도와는 맞지 않게 실제로는 언제든 해당 클래스들의 개체를 생성할 수도 있다는 문제가 있음.

  즉, 부모로부터 상속받은 메서드를 자식이 반드시 구현하도록 하고  
  자식들의 공통 분모만 뽑아내서 분류한 클래스의 인스턴스 생성을 막고 싶음.  
  => 추상 클래스(abstrack class) 사용

  ``` 
  public abstract class Monster{ // 추상 클래스로 선언하였으며, 이로 인해 Monster 클래스의 개체 생성 불가
      public abstract int attack(Monster target); // 자식들은 이러한 추상 메서드인 attack 메서드를 반드시 오버라이딩 해야 함(안그러면 컴파일 오류)
  }
  ```

  - 추상 클래스라 하더라도 반드시 추상 메서드만 있지는 않아도 됨.
  - 단, 추상 메서드가 있다면 그 클래스는 반드시 추상 클래스로 선언되어야 함.  
  ex) BaseEntity 클래스


- **인터페이스(Interface)** : 오로지 함수의 시그니처(반환 타입, 함수명, 매개변수)만 있고 상태나 함수의 구현이 없는 순수 추상 클래스로,  
  해당 인터페이스를 구현(implements)하는 클래스에서 그 함수들을 직접 구현함.
  - 추상 클래스처럼 인터페이스에서 선언된 메서드들도 implements하는 클래스에서 모두 구현을 안하면 컴파일 오류  
     => 덕분에 상속받은 메서드명을 실수로 오타내거나 부모클래스에서 선언된 메서드명을 바꾸고나서 실수로 자식에서는 바꾸지 않은 경우 발생할 수 있는 문제 예방 가능
  - 인터페이스는 무조건 public이며(public 키워드 생략해도 public), 인터페이스 내 메서드도 별도로 public 키워드를 붙이지 않아도 모두 자동으로 public
  - 인터페이스는 무조건 같은 패키지 안에서만 import해서 사용 가능
  - 인터페이스는 다중 상속이 가능


- **추상 클래스(Human)를 인터페이스로 바꿔보기** : 추상 클래스와 인터페이스는 실직적으로 같은 기능(동작의 선언과 구현을 분리) 제공
  ``` 
  public abstract class Human { // 추상 클래스
      public abstract void talk(String msg);
  }

  public class Teacher extends Human { // Teacher 클래스가 추상 클래스인 Human을 상속
      public void talk(String msg) {
          ...
      }
  }
  ```
  ``` 
  public interface IHuman { // 인터페이스명 앞에는 'I'를 붙여서 클래스와 구분해주자!
      void talk(String msg); // 인터페이스의 메서드는 언제나 public
  }

  public class Teacher implements IHuman { // Teacher 클래스가 인터페이스인 IHuman을 구현
      public void talk(String msg) {
          ...
      }
  }
  ```


- **※ JAVA 어노테이션** : 메서드 위에 @Override, @Deprecated 와 같은 표기를 함으로써 컴파일러 및 해당 코드 사용자에게 프로그래머의 의도를 전달하고,  
  컴파일/빌드 중에 사용한 어노테이션 기반으로 관련된 처리를 쉽게 할 수 있음.
  - @Deprecated : 해당 메서드는 언젠가 지원이 끊길 예정
  - @Override : 해당 메서드는 부모로부터 상속받아 오버라이드함
  ```
  // 어노테이션 예시
  public class Teacher extends Human {
      @Override // Human 클래스로부터 상속받은 talk 메서드를 오버라이드 한다고 표기
      public void talk(String msg) { // 만약 @Override 메서드와 맞는 함수 시그니처가 부모에 없으면 컴파일 오류
          ...
      }
  }
  ```
  
- **인터페이스와 다중상속** : 인터페이스는 다중 상속(implements) 가능.  
  (인터페이스 implements와 클래스 상속은 사실상 같은 기능이라고 보면 됨)
  - 이미 각각 구현이 된 동일 메서드 시그니처를 가진 여러 클래스를 상속받는 경우엔,   
    자식이 어느 부모의 메서드를 상속받아야 하는지 명확하지 않기 때문에 이러한 다중 상속은 불가능하지만,  
    인터페이스의 경우엔 구현은 없고 오로지 메서드 시그니처만 있기 때문에   
    implements하는 클래스가 그 중 하나의 메서드 시그니처만 가져와서 구현하면 됨.
  - 단, 다중 implements하는 인터페이스들의 메서드 시그니처가 메서드명과 매개변수가 같지만 반환형이 다른 경우엔  
    메서드 오버로딩이 불가능하므로 이런 경우엔 다중 implements 불가.
  - 여러 인터페이스를 implements한 경우, 그 인터페이스들의 메서드 시그니처를 모두 구현해야 하며, 안그러면 컴파일 오류.
  ```
  public interface IHuman {
      void walk();
      int getWeight();
  }

  public interface IAminmal {
      void walk();
      float getWeight();
  }

  public class HumanAndAnimal implements IHuman, IAnimal { // HumanAndAnimal이 IHuman과 IAnimal 인터페이스 다중상속받아서 구현
      void walk(); // 어차피 구현은 HumanAndAnimal에서 하기 때문에 IHuman과 IAnimal의 동일 시그니처 메서드 중 아무 walk()를 가져와도 문제 발생 X
      int getWeight(); // 메서드명과 매개변수가 같지만 반환형이 다른 경우에는 오버로딩이 불가능하기 때문에 이런 경우도 불가능
  }
  ```
  - 즉, 인터페이스의 핵심은 1)함수 포인터처럼 메서드의 선언과 구현을 분리 가능, 2)다중 상속 가능


- **인터페이스 vs 추상 클래스**
  - 인터페이스는 다중 상속 지원
  - 추상 클래스는 단일 상속만 지원하고, 자식 클래스들의 공통된 멤버(변수, 메서드)들을 통합 및 확장 가능


- **Object.clone()** : 클래스 복사 메서드  
  대입자로 복사할 경우엔 단지 클래스 객체의 주소만 복사할 뿐, 진짜 클래스 자체의 복사를 원할 경우엔  
  아래와 같이 Clonable 인터페이스를 상속(implements)받은 후 Object.clone() 메서드를 직접 구현해야 함.  
  ```
  /* 얕은 복사 */
  public final class Robot implements Clonable {
      ...
      public Object clone() throws CloneNotSupportedException {
          /*
            해당 객체가 가지고 있는 값을 복사한 객체에 대입해줌
            단, 이런 경우 값형 변수의 경우엔 문제가 없지만,
            클래스같은 참조형 변수의 경우엔 기존 객체에 포함된 참조형 변수가 
            가리키는 주소를 복사해서 대입(얕은 복사)하기 때문에
            깊은 복사를 하기 위해선 추가적인 작업이 필요함
          */
          return super.clone();
      }
  }  
  ```
  ```
  /* 깊은 복사 */
  public final class Head implements Clonable {
      /*
      Robot에 포함되어 있는 Head 클래스형 변수에 대해서도 깊은 복사를 지원하기 위해
      Head 클래스도 Clonable 상속 후 clone() 메서드 구현 필요
      */
      ...
      // 만약 Clonable 인터페이스를 상속받지 않고 clone() 메서드를 오버라이딩 하면 CloneNotSupportedException 예외 발생
      public Object clone() throws CloneNotSupportedException {
          return super.clone();
      }
  }

  public final class Robot implements Clonable {
      private Head head = new Head();
      ...
      public Object clone() throws CloneNotSupportedException {
          Robot cloned = (Robot)super.clone();
          cloned.head = (Head)head.clone();
          return cloned;
      }
  }
  ```

- **복사생성자** : C++에서 지원하는 방식으로, 깊은 복사가 가능
  ``` 
  public final class Point {
      private int x;
      private int y;

      public Point(final int x, final int y) {
          this.x = x;
          this.y = y;
      }

      public Point(Point other) {
          this(other.x, other.y);
      }
  }

  public final class Line {
      private Point p1;
      private Point p2;

      public Line(Point p1, Point p2) {
          this.p1 = p1;
          this.p2 = p2;
      }
    
      /* 복사 생성자를 통한 깊은 복사 진행 */
      public Line(Line other) {
          this(new Point(other.p1),
               new Point(other.p2));
      }
  }
  ```

- **구체 클래스 vs 인터페이스(=순수 추상 클래스)**
  - 구체 클래스 : 상태와 동작을 모두 포함 / 동작에 다양한 접근권한 부여 가능 / 개체 생성 가능 / 다중 상속 불가
  - 인터페이스 : 동작에 대한 선언만 포함 / 모든 동작은 public / 개체 생성 불가 / 다중 상속 가능
