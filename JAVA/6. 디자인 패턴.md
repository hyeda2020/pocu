# 6. 디자인 패턴
- **디자인 패턴** : 단지 문제 해결 관련 가이드일 뿐, 디자인 패턴 자체가 문제를 해결해 주지는 않음.
  - 디자인 패턴 배웠다고 해서 절대 바로 사용하려고 하지 않기(코드가 이상해진다!)
  - 해당 패턴을 딱 봤을 때 코드가 익숙하면 그때가 바로 디자인 패턴을 스스로 적용해볼 수 있는 시기  
  (패턴을 처음 봤을 때 익숙하지 않다면 그 문제를 못 접해봤고, 그 해법도 고민을 못해봤다는 의미)


- **팩토리 메서드 패턴** : 사용할 클래스 정보를 정확히 몰라도 개체 생성을 가능하게 해주는 패턴
  ```  
  public enum CupSize {
      SMALL,
      MEDIUM,
      LARGE
  }
  
  public final class Cup {
      private int sizeMl;

      private Cup(int sizeMl) { // 생성자는 private
          this.sizeMl = sizeMl;
      }

      // 생성자 대신 size에 맞는 컵을 알아서 생성 후 리턴해줌
      public static Cup createOrNull(CupSize size) {
          switch (size) {
              case SMALL:
              return new Cup(355);
              case MEDIUM:
              return new Cup(473);
              case LARGE:
              return new Cup(651);
              default:
              assert (false) : "Unhandled CupSize:" + size;
              return null;
          }
      }
  }
  ```
  - 생성자의 경우는 반환하는 것이 없기 때문에 개체 생성시 문제가 생길 경우 오직 예외를 던지는 방법밖에 없지만,  
  이러한 팩토리 메서드 패턴은 개체 생성때 문제가 생기면 null을 반환 가능하다는 장점이 있음.
  - 여기에 다형성을 적용해보면 Cup 클래스를 추상 클래스로 바꾸고,   
  이를 상속하는 PaperCup이나 PlasticCup 클래스를 자식으로 만들어서  
  각 클래스 성격에 맞는 createOrNull 메서드를 오버라이딩하여 사용하면 됨. 


- **빌더 패턴** : StringBuilder처럼 해당 개체의 부분부분을 만들어 나가다가 준비가 되면 그 때 해당 개체를 완성(.toString())시켜 생성
  ```  
  builder.append(heading)
          .append('\n')
          .append('\n');
  플루언트 인터페이스 처럼 append에서 자기 자신을 리턴하여 계속 이어붙여 나가는 방식
  ```


- **래퍼/어댑터 패턴** : 어떤 클래스의 메서드 시그내처가 맘에 안 들 때,(해당 클래스에 의존하는 다른 클래스에 영향도를 없애기 위해서)  
그 클래스의 메서드 시그내처를 바꾸는 대신 새로운 클래스를 만들어 기존 클래스를 감싸는 방법  
  - 래퍼/어댑터 패턴 사용 이유
    - 추후 내부에서 변동사항이 생길 때 클라이언트 코드를 변경하지 않기 위해
    - 사용중인 외부 라이브러리가 우리의 코딩 표준과 맞지 않을 때
    - 기존 클래스에 없는 기능을 추가하려고 하는데, 기존 클래스에 추가하기에는 어렵고 아예 새로운 클래스를 별도로 만들기에는 좀 애매하다 싶으면 기존 클래스를 감싸는 새로운 클래스를 만들고, 그 새로운 클래스에 새로운 기능을 추가함. 그리고 기존 클래스를 사용하기 위해서는 반드시 새로운 클래스를 통해서만 사용 가능하게끔 함
    - 내부 개체를 클라이언트에 노출시키지 않기 위해(ex. DTO)
  ```
  // 클라이언트 코드를 변경하지 않기 위해 래퍼/어댑터 패턴 사용 예시
  
  /* OpenGL의 화면을 clear시키는 메서드(clearScrean)를 Graphics 클래스로 감쌈 */
  public final class Graphics {
      private OpenGL gl;

      public void clear(float r, float g, float b, float a) {
          this.gl.clearScrean(a, r, g, b); // OpenGL에서 화면을 clear시키는 메서드
      }
  }

  /* 만약에 기존 OpenGL에서 DirectX로 바꾸고 싶다면?
  코드 두 줄만 수정하면 클라이언트 코드 수정 없이 OpenGL -> DirectX로 손쉽게 전환 가능 */
  public final class Graphics {
      // private OpenGL gl;
      pviate DirectX dx; // OpenGL 클래스는 주석처리하고 새로 DirectX 클래스 선언

      // DirectX에서 화면을 clear시키는 메서드로 전환
      public void clear(float r, float g, float b, float a) {
          // this.gl.clearScrean(a, r, g, b); // OpenGL에서 화면을 clear시키는 메서드를 주석 처리
          this.dx.clear((int)(r * 255), (int)(g * 255), (int)(b * 255), (int)(a * 255)); 
      }
  }  
  ```
  - 래퍼 패턴과 DTO : 클라이언트가 필요한 데이터만을 별도의 데이터 전송만을 위한 DTO클래스에 담아서 전달.  
  => 클라이언트에 굳이 필요 없는 데이터를 보내지 않을 수 있고, 보안상의 이점도 있음


- **프록시 패턴(지연 로딩 + 캐싱)** : 시간이 오래 걸리는 특정 작업을 클래스가 해야 될 때(ex. 용량이 큰 파일 데이터 읽어오기),  
  개체 생성 시에는 파일 경로 같은 해당 작업을 수행하기 위해 필요한 정보만 저장해 두었다가  
  실제 클라이언트가 해당 작업을 요청할 때 수행하고, 그 작업을 수행하면서 불러온 큰 데이터가 있다면 그 데이터를 캐싱해 둠.  
  따라서 이후에 해당 작업이 또 수행하게 되면 다시 큰 데이터를 불러오지 않고 캐싱해 둔 데이터 사용.  
  - 프록시 패턴 사용시 주의할 점
    - 만약 최신의 데이터가 필요하다면 지연 로딩보다는 즉시 로딩 사용
    - 메모리 사용량을 최소화 해야한다면 지연 로딩하되, 캐싱하지 않는 것이 효율적
  - 결국 이런 케이스에는 클라이언트가 상황에 맞게 직접 클래스의 즉시로딩/지연로딩/캐싱 동작을 파악하고 사용할 수 있도록 하는 것이 중요!  
    즉, 작업 수행의 캡슐화를 통해 클라이언트가 내부 동작을 모르던 것을 세분화하여  
    데이터를 읽어왔는지 확인(isLoaded), 데이터를 즉시 로드(load), 데이터 저장(save), 데이터 언로드(unload)로 구분하고  
    클라이언트가 상황에 맞게 이 구분된 메서드들을 활용하여 지연로딩/즉시로딩/프록시 패턴을 사용하도록 하는 것이 올바른 방식!  


- **책임 연쇄 패턴** : 어떤 작업을 수행하는 여러 개체가 있을 때, 그 개체들은 해당 작업을 수행할 수 있는 기회를 차례로 부여 받음.  
  만약 그중 한 개체가 그 작업을 수행완료하면 그에 대한 책임을 지고, 해당 작업 프로세스를 바로 종료해버림으로써 다음 차례 개체들은 작업 수행 기회를 부여받지 않음.  
  ex) LogLevel(INFO, DEBUF, ERROR)에 따른 로그 출력 내용 단계 등 

  
- **Pub-Sub 패턴** : 발행자(Publisher)가 있고 그 발행자의 상태가 변할때 특정 작업을 수행해야 되는 구독자(Subscriber)가 있는 패턴.  
  주로 발행자와 구독자는 다대다 구조를 이루며 그 중간에서 발행자와 구독자 사이를 조율하는 Manager 클래스가 있음.  
  - 메모리 누수 관련 이슈 : Maganer 클래스에 ArrayList로 pub과 sub 객체를 담아서 관리하는 상태일 때,  
    sub 하나가 구독을 취소하면 반드시 Manager 클래스의 ArrayList에서 해당 sub 객체를 remove 시켜줘야 함.  
    만약 그렇지 않으면 ArrayList에서 여전히 구독을 취소한 sub을 참조하고 있기 때문에 GC에서 해당 객체를 정리하지 않음!