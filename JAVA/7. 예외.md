# 7. 예외
- **try/catch/finally**
  ```  
  /* Exception 클래스는 모든 예외 클래스의 최상위 클래스이므로
  만약 아래 IOException catch 블록과 Exception catch 블록의 순서가 바뀌면 IOException은 절대 실행되지 않음 */
  try {
  ...
  } catch(IOException e) {
  ...
  } catch(Exception e) {
  ...
  } finally {
  ...
  }
  ```
  1. 오류가 나면 try 블록에서 해당 라인까지만 실행하고 이후는 실행 중단
  2. catch 블록 중에 발생한 예외를 처리할 수 있는 블록이 있는지 위에서부터 하나씩 찾음
  3. if 예외를 처리할 수 있는 catch 블록이 있다면  
         해당 catch 블록 안의 코드들이 실행  
         finally 블록 실행  
         try 블록 이후의 코드들이 실행됨  
     else // 예외를 처리할 수 있는 catch 블록이 없음  
     finally 블록 실행 후 한 단계 높은 try 문으로 이동  


- **예외 다시 던지기(rethrow)** : try-catch문으로 예외를 받았는데, 해당 catch문에서 예외처리를 안하고 바로 다른 곳으로 넘겨버리는 방법.   
  => 가급적이면 쓰지 말자!


- **나만의 예외 만들기**
  ```
  public final class UserNotFoundException extends RunTimeException { // RunTimeException 클래스 상속
      public UserNotFoundException() {
          super(); // 자식 클래스에서 반드시 super로 부모 클래스를 호출해줘야 됨
      }

      public UserNotFoundException(String message) {
          super(message);
      }

      public UserNotFoundException(String message, Throwable cause) {
          super(message, cause);
      }
  }  
  ```
  

- **자바 프로그램에서 예외처리를 안해줄 경우 발생하는 일** :   
  발생한 오류에 대한 예외를 main() 메서드에서조차 처리를 해주지 않으면 JVM에서 예외를 받아서 프로그램 강제 종료를 시킴 


- **함수와 예외 Throw**
  - 만약, 함수마다 예외를 던진다면 함수 호출자는 각각의 함수에서 어떤 예외를 던질지 직접 함수 내부를 까봐야만 알 수 있으며,  
    이를 모두 확인해서 try-catch문으로 예외처리를 하는 것은 사실상 불가능.  
    (자바에서는 checked/unchecked 예외 기능을 통해 이를 일부 보완)  
  - 결국 중요한 것은 함수마다 예외를 던지는 것이 아니라, 함수 선언자와 호출자간에는 함수 시그내처, 함수명을 통해  
    해당 함수가 어떤 인자를 필요로 하고, 어떤 기능을 하고, 어떤 것을 리턴하는지 서로 통신해야 하며  
    함수 내부에서 예외가 발생했을 경우 또한 에러코드같은 것이나 boolean 타입값을 리턴함으로써 함수 호출자에게 오류 상황을 알려주는 방법을 사용하는 것이 좋음.


- **checked 예외** : 컴파일러가 예외 처리를 제대로 해주는지 확인해줌(자바 예외처리의 기본 동작)
  - Exception과, 이를 상속받는 모든 익셉션들(IOException, SQLException, TimeoutException 등)
  - 가령, 함수 A가 함수 B를 호출하는데, B에서 IOException을 던지고 있다면, 
    1) 함수 A 내에 B 함수를 호출하는 부분에서 try-catch문을 통한 예외처리를 하지 않거나, 
    2) A가 함수 시그내처 부분에서 throw를 통해 상위 함수로 해당 예외를 넘기지 않을 경우 컴파일 오류 발생  
  - 즉, `public String funcA(String arg) throws IOException { ... }` 이렇게 메서드 시그내처 부분에서 throws 절로 예외를 상위 레벨로 올리면    
    try-catch로 IOException 예외처리를 하지 않더라도 컴파일 오류를 피할 수 있음.  
    (그럼 상위 레벨 함수에서는 반드시 해당 예외를 처리해줘야 함)


- **unchecked 예외** : 다른 언어에서의 일반적인 예외
  - RuntimeException과, 이를 상속받는 모든 익셉션들(ArithmeticException, BufferOverflowException, ClassCastException 등)


- **예외로부터 안전한 프로그래밍**
  - 가령, 주문 서비스 시스템이 있다고 가정 할 때, 고객의 포인트 차감 -> 재고 갱신 -> 주문 넣기 식으로 로직이 진행되다가 주문 넣기에서 예외가 발생했을 경우  
    이를 회복하는 것은 다시 주문 넣기 -> 재고 갱신 -> 고객의 포인트 회복 이런 방법으로 돌아가게 됨.  
    허나, 시스템이 복잡해질수록 모든 로직에 이러한 예외 발생 후 회복하는 처리 코드를 작성하는 것은 사실상 불가능.  
  - 결국 정말 중요하고 핵심적인 부분만 확실하게 예외로부터 안전한 safe 상태를 보장하고,  
    그 외에는 우선순위에 따라 차라리 로직이 실패하도록 내버려 두는 것이 더 실용적인 방법일 수 있음.


- **예외를 활용한 흐름제어** : 절대 제어흐름용으로 예외를 사용하지 말자!
  - 호출스택 어디로도 점프가 가능해지므로 잘못 사용하면 프로그램이 꼬일 위험이 있음.
  - 제어흐름용 예외로 인해 진짜 예외 상황을 놓치기 쉬워짐(컴파일러 경고는 뜰 때마다 반드시 고쳐야 하는 이유와 같음)


- ※ IDE의 예외중단점(특정 예외가 발생했을때 해당 위치로 바로 이동해주는 기능)을 적극적으로 활용하자!


- **오류 상황을 처리하는 4가지 방법** : 무시, 종료, 수정 후 재배포, 예외처리  
  - 여기서 try-catch문을 통한 예외처리는 객체지향 언어 이후로 등장한 방법.  
  - 단, 객체지향 언어를 사용한다고 해서 반드시 try-catch문으로만 오류 상황을 처리해야 한다는 법은 없으며,  
    상황에 따라 오류 상황이 발생했을 때 프로그램을 종료하거나 즉시 수정 후 재배포 하는 방법이 더 나을 수도 있음.


- **예외처리 원칙** : 
  내가 관리하는 코드 영역들에서는 언제나 함수들은 올바르게 작동하고 유효한 데이터들만 전달된다 가정하고 개발하되,  
  (그리고 내가 관리하는 코드 영역에서는 실제로 이런 유효하고 깔끔한 상태가 되게끔 버그를 만들지 않게 잘 개발해야 됨)  
  외부에서 들어오는 데이터들에 대해서는 반드시 의심하고 꼼꼼하게 예외처리 하기  
  

- **잘못된 예외처리보다는 오히려 프로그램 종료가 더 나을 수 있다!** :  
  잘못된 예외처리로 인해 프로그램이 비정상인 상태로 계속 동작하는 것보다는  
  차라리 자동 저장 기능 활용 또는 사용자한테 오류상황임을 알리고 현재 상황 저장 뒤 프로그램 정상 종료하는 것이 더 나을수 있으며,  
  크래시가 난 경우 메모리 덤프 분석을 통해 예외 처리보다 문제 상황을 더욱 자세하게 파악 가능할 수 있음.  


- **정리**  
  결국엔 최종적으로는 좀비 프로그램이 되는 상황을 피하는 것이 최우선 순위가 되어야 하며,  
  4가지 오류 상황들(무시, 종료, 수정 후 재배포, 예외처리)를 적절하게 골고루 활용해서  
  적당한 순간에 크래시 내서 메모리 덤프 분석하고,  
  적당한 순간에 프로그램 종료시키고,  
  적당한 순간에 예외 발생시켜서 상황을 고쳐서 진행하고,  
  적당한 순간에 오류코드 리턴해서 예외처리 하는 것이 중요함.  

